<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>树莓派4B-配置和注意事项</title>
      <link href="/2021/07/02/study_blog/Linux/2021-07-02-raspberry/"/>
      <url>/2021/07/02/study_blog/Linux/2021-07-02-raspberry/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h3><ul><li>[下载]<br>在<a href="https://www.raspberrypi.org/software/">官网</a>下载安装包，并检验镜像包是否完整</li><li>[烧录] <ul><li>linux : sudo dd if=**.iso of=/dev/sdb </li><li>windows下: 请通过官方提供的烧录软件或refus等烧录</li></ul></li><li>[开机配置时区、密码]<ul><li>时区选择shanghai，并更新一下时间，时区错误或者不对可能导致浏览器错误，或者终端无法打开</li></ul></li><li>[换源、更新软件包]<br>若觉得默认源速度慢，可通过换源提升速度，参考<a href="https://zhuanlan.zhihu.com/p/129881626#:~:text=%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%B7%E5%A5%BD%E7%B3%BB%E7%BB%9F%E5%90%8E%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%E9%83%BD%E6%98%AF%E5%9B%BD%E5%A4%96%E7%9A%84%E6%BA%90%EF%BC%8C%E6%89%80%E4%BB%A5%E8%AF%B4%E5%8F%8A%E5%85%B6%E7%9A%84%E6%85%A2%E3%80%82%20%E5%8F%AF%E4%BB%A5%E6%8D%A2%E6%88%90%E5%9B%BD%E5%86%85%E7%9A%84%E6%BA%90%E3%80%82%20%E5%85%B6%E5%AE%9E%E5%BE%88%E7%AE%80%E5%8D%95%20%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0codename%E4%B8%BAbuster%2C%E6%89%80%E4%BB%A5%E4%B8%80%E4%BC%9A%E6%8D%A2%E6%BA%90%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%80%E5%AE%9A%E8%A6%81%E8%AE%B0%E4%BD%8F%E3%80%82%201%3Anano%20%E7%BC%96%E8%BE%91%2Fetc%2Fapt%2F%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84sources.list%20%E7%BB%88%E7%AB%AF%E8%BE%93%E5%85%A5%EF%BC%9Asudo%20nano,%E6%89%93%E5%BC%80%E7%BB%88%E7%AB%AF%EF%BC%9A%20%E8%BF%99%E9%87%8C%E6%88%91%E5%B7%B2%E7%BB%8F%E8%A3%85%E5%AE%8C%E4%BA%86%E3%80%82%20%E8%BF%99%E9%87%8C%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BD%A0%E8%A3%85%E4%B9%8B%E5%89%8D%E4%B8%80%E5%AE%9A%E8%A6%81%E6%9C%89numpy%E8%BF%99%E4%B8%AA%E5%BA%93%E3%80%82%20%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%E5%88%B7%E5%AE%8C%E7%B3%BB%E7%BB%9F%E5%B0%B1%E6%9C%89%E4%BA%86%E3%80%82%20%E8%A3%85%E5%AE%8C%E4%B9%8B%E5%90%8E%E4%BD%A0%E5%8F%AF%E4%BB%A5%E7%BB%88%E7%AB%AF%E8%BE%93%E5%85%A5python3%E5%9B%9E%E8%BD%A6%E3%80%82%20%E8%BE%93%E5%85%A5import%20cv2%20%E7%84%B6%E5%90%8E%E5%9B%9E%E8%BD%A6%E3%80%82">网站</a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 换源好之后更新数据和软件包</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h3 id="安装摄像头"><a href="#安装摄像头" class="headerlink" title="安装摄像头"></a>安装摄像头</h3></li><li>[连接摄像头模块] 注意针脚有正反之别，直接看针脚来区分即可</li><li>[打开摄像头模块] 打开树莓中，并重启。</li><li>[测试是否可用] <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raspistill -o tmp.jpg <span class="comment">#若能拍照，则ok。</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="opencv"><a href="#opencv" class="headerlink" title="opencv"></a>opencv</h3><ul><li>python2<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libopencv-dev</span><br><span class="line">sudo apt-get install python-opencv</span><br></pre></td></tr></table></figure></li><li>python3<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3  install opencv-python <span class="comment">#安装之前需要有numpy库</span></span><br><span class="line"><span class="comment"># 若测试导入，提示缺失模块，测运行如下安装模块</span></span><br><span class="line">sudo apt-get install libhdf5-dev</span><br><span class="line">sudo apt-get install libatlas-base-dev</span><br><span class="line">sudo apt-get install libjasper-dev</span><br><span class="line">sudo apt-get install libqt4-test</span><br><span class="line">sudo apt-get install libqtgui4</span><br></pre></td></tr></table></figure></li><li>编译系列<br><a href="https://docs.opencv.org/master/d7/d9f/tutorial_linux_install.html">参考文件</a></li><li>测试<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3 <span class="comment">#打开python</span></span><br><span class="line">import cv2 <span class="comment">#导入库</span></span><br><span class="line">cv2.__version__ <span class="comment"># 查看版本号</span></span><br></pre></td></tr></table></figure><h2 id="常用服务"><a href="#常用服务" class="headerlink" title="常用服务"></a>常用服务</h2><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3></li><li>管理面版打开<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br><span class="line"><span class="comment"># 选择 Interfacing Options-&gt; SSH</span></span><br></pre></td></tr></table></figure></li><li>终端自助打开<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start sshd <span class="comment">#开始服务</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> sshd <span class="comment">#enable服务</span></span><br></pre></td></tr></table></figure><h3 id="vnc"><a href="#vnc" class="headerlink" title="vnc"></a>vnc</h3></li><li>管理面版打开<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br><span class="line"><span class="comment"># 选择 Interfacing Options-&gt; VNC</span></span><br></pre></td></tr></table></figure></li><li>终端自助打开<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start vncserver  <span class="comment">#开始服务</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> vncserver <span class="comment">#enable服务</span></span><br></pre></td></tr></table></figure><h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3></li><li>终端自助打开<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件位置/etc/vsftpd.conf ,默认通过本地用户访问</span></span><br><span class="line">sudo systemctl start vncserver  <span class="comment">#开始服务</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> vncserver <span class="comment">#enable服务</span></span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注：[]表示变量，相应的替换即可</span></span><br><span class="line">ip addr                                        <span class="comment"># 显示当前ip地址和网口信息</span></span><br><span class="line">ip link <span class="built_in">set</span> [interface] up/down                <span class="comment"># 设置网口开关</span></span><br><span class="line">wpa_passphrase <span class="string">&quot;[热点名称]&quot;</span> <span class="string">&quot;[密码]&quot;</span> &gt;[config] <span class="comment"># 生成配置文件</span></span><br><span class="line">wpa_supplicant -B -i [interface] -c [config]   <span class="comment"># 通过配置文件连接wifi</span></span><br><span class="line">dhclient [无线网口]                            <span class="comment"># 无线网口获取ip</span></span><br><span class="line">dhcpcd &amp;                                       <span class="comment"># 以太网口获取ip</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注：以下命令在root用户下执行</span></span><br><span class="line">systemctl start [server_name]     <span class="comment"># 启动服务</span></span><br><span class="line">systemctl stop [server_name]      <span class="comment"># 停止服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> [server_name]    <span class="comment"># enable服务</span></span><br><span class="line">systemctl disenable [server_name] <span class="comment"># disenable服务</span></span><br><span class="line">systemctl status [server_name]    <span class="comment"># 查看服务状态</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> raspberry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++_base</title>
      <link href="/2021/06/15/study_blog/cpp/2021-06-15-C++_base/"/>
      <url>/2021/06/15/study_blog/cpp/2021-06-15-C++_base/</url>
      
        <content type="html"><![CDATA[<p><strong>本文为个人学习时的笔记，<a href="https://www.bilibili.com/video/BV1et411b73Z?p=1">资料出处及源地址</a></strong></p><h2 id="1-C-初识"><a href="#1-C-初识" class="headerlink" title="1 C++初识"></a>1 C++初识</h2><h3 id="1-1-第一个C-程序"><a href="#1-1-第一个C-程序" class="headerlink" title="1.1 第一个C++程序"></a>1.1 第一个C++程序</h3><ul><li>编写一个C++程序总共分为4个步骤<ul><li>创建项目</li><li>创建文件</li><li>编写代码</li><li>运行程序<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3></li></ul></li><li>作用：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码</li><li>两种格式<ul><li>单行注释：// 描述信息</li><li>多行注释： /* 描述信息 */<h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3></li></ul></li><li>作用：给一段指定的内存空间起名，方便操作这段内存</li><li>语法：数据类型 变量名 = 初始值;</li><li>注意：C++在创建变量时，必须给变量一个初始值，否则会报错</li></ul><h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4 常量"></a>1.4 常量</h3><ul><li>作用：用于记录程序中不可更改的数据</li><li>两种方式<ul><li>define 宏常量： #define 常量名 常量值</li><li>const修饰的变量 const 数据类型 常量名 = 常量值</li></ul></li></ul><h3 id="1-5-关键字"><a href="#1-5-关键字" class="headerlink" title="1.5 关键字"></a>1.5 关键字</h3><ul><li>作用：关键字是C++中预先保留的单词（标识符）</li></ul><table><thead><tr><th>asm</th><th>do</th><th>if</th><th>return</th><th>typedef</th></tr></thead><tbody><tr><td>aut</td><td>double</td><td>inline</td><td>short</td><td>j typeid</td></tr><tr><td>bool</td><td>dynamic_cast</td><td>int</td><td>signed</td><td>typename</td></tr><tr><td>break</td><td>else</td><td>long</td><td>sizeof</td><td>union</td></tr><tr><td>case</td><td>enum</td><td>mutable</td><td>static</td><td>unsigned</td></tr><tr><td>catch</td><td>explicit</td><td>namespace</td><td>static_cast</td><td>using</td></tr><tr><td>char</td><td>export</td><td>new</td><td>struct</td><td>virtual</td></tr><tr><td>class</td><td>extern</td><td>operator</td><td>switch</td><td>void</td></tr><tr><td>const</td><td>false</td><td>private</td><td>template</td><td>volatile</td></tr><tr><td>const_cast</td><td>float</td><td>protected</td><td>this</td><td>wchar_t</td></tr><tr><td>continue</td><td>for</td><td>public</td><td>throw</td><td>while</td></tr><tr><td>default</td><td>friend</td><td>register</td><td>true</td><td></td></tr><tr><td>delete</td><td>goto</td><td>reinterpret_cast</td><td>try</td><td></td></tr></tbody></table><ul><li>提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。</li></ul><h3 id="1-6-标识符命名规则"><a href="#1-6-标识符命名规则" class="headerlink" title="1.6 标识符命名规则"></a>1.6 标识符命名规则</h3><ul><li>作用：C++规定给标识符（变量、常量）命名时，有一套自己的规则<ul><li>标识符不能是关键字</li><li>标识符只能由字母、数字、下划线组成</li><li>第一个字符必须为字母或下划线</li><li>标识符中字母区分大小写</li></ul></li></ul><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h2><ul><li>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存<h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3></li><li>作用：整型变量表示的是整数类型的数据</li><li>C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同：</li></ul><table><thead><tr><th>数据类型</th><th>占用空间</th><th>取值范围</th></tr></thead><tbody><tr><td>short(短整型)</td><td>2字节</td><td>(-2^15 ~ 2^15-1)</td></tr><tr><td>int(整型)</td><td>4字节</td><td>(-2^31 ~ 2^31-1)</td></tr><tr><td>long(长整形)</td><td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td><td>(-2^31 ~ 2^31-1)</td></tr><tr><td>long long(长长整形)</td><td>8字节</td><td>(-2^63 ~ 2^63-1)</td></tr></tbody></table><h3 id="2-2-sizeof关键字"><a href="#2-2-sizeof关键字" class="headerlink" title="2.2 sizeof关键字"></a>2.2 sizeof关键字</h3><ul><li>作用：利用sizeof关键字可以统计数据类型所占内存大小</li><li>语法： sizeof( 数据类型 / 变量)<blockquote><ul><li>整型结论：short &lt;int&lt;=long&lt;=long long</li></ul></blockquote></li></ul><h3 id="2-3-实型（浮点型）"><a href="#2-3-实型（浮点型）" class="headerlink" title="2.3 实型（浮点型）"></a>2.3 实型（浮点型）</h3><ul><li>作用：用于表示小数</li><li>两种：<ul><li>单精度float</li><li>双精度double</li></ul></li></ul><table><thead><tr><th>数据类型</th><th>占用空间</th><th>有效数字范围</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>7位有效数字</td></tr><tr><td>double</td><td>8字节</td><td>15～16位有效数字</td></tr></tbody></table><h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><ul><li>作用：字符型变量用于显示单个字符</li><li>语法：char ch = ‘a’;<ul><li>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号</li><li>注意2：单引号内只能有一个字符，不可以是字符串</li><li>C/C++中字符型变量只占用1个字节。</li><li>字符型变量不是字符本身，而是将对应的ASCII编码</li></ul></li><li>ASCII码表格：</li></ul><table><thead><tr><th>ASCII值</th><th>控制字符</th><th>ASCII值</th><th>字符</th><th>ASCII值</th><th>字符</th><th>ASCII值</th><th>字符</th></tr></thead><tbody><tr><td>0</td><td>NUT</td><td>32</td><td>(space)</td><td></td><td>64</td><td>@</td><td>96</td></tr><tr><td>1</td><td>SOH</td><td>33</td><td>!</td><td>65</td><td>A</td><td>97</td><td>a</td></tr><tr><td>2</td><td>STX</td><td>34</td><td>“</td><td>66</td><td>B</td><td>98</td><td>b</td></tr><tr><td>3</td><td>ETX</td><td>35</td><td>#</td><td>67</td><td>C</td><td>99</td><td>c</td></tr><tr><td>4</td><td>EOT</td><td>36</td><td>$</td><td>68</td><td>D</td><td>100</td><td>d</td></tr><tr><td>5</td><td>ENQ</td><td>37</td><td>%</td><td>69</td><td>E</td><td>101</td><td>e</td></tr><tr><td>6</td><td>ACK</td><td>38</td><td>&amp;</td><td>70</td><td>F</td><td>102</td><td>f</td></tr><tr><td>7</td><td>BEL</td><td>39</td><td>,</td><td>71</td><td>G</td><td>103</td><td>g</td></tr><tr><td>8</td><td>BS</td><td>40</td><td>(</td><td>72</td><td>H</td><td>104</td><td>h</td></tr><tr><td>9</td><td>HT</td><td>41</td><td>)</td><td>73</td><td>I</td><td>105</td><td>i</td></tr><tr><td>10</td><td>LF</td><td>42</td><td>*</td><td>74</td><td>J</td><td>106</td><td>j</td></tr><tr><td>11</td><td>VT</td><td>43</td><td>+</td><td>75</td><td>K</td><td>107</td><td>k</td></tr><tr><td>12</td><td>FF</td><td>44</td><td>,</td><td>76</td><td>L</td><td>108</td><td>l</td></tr><tr><td>13</td><td>CR</td><td>45</td><td>-</td><td>77</td><td>M</td><td>109</td><td>m</td></tr><tr><td>14</td><td>SO</td><td>46</td><td>.</td><td>78</td><td>N</td><td>110</td><td>n</td></tr><tr><td>15</td><td>SI</td><td>47</td><td>/</td><td>79</td><td>O</td><td>111</td><td>o</td></tr><tr><td>16</td><td>DLE</td><td>48</td><td>0</td><td>80</td><td>P</td><td>112</td><td>p</td></tr><tr><td>17</td><td>DCI</td><td>49</td><td>1</td><td>81</td><td>Q</td><td>113</td><td>q</td></tr><tr><td>18</td><td>DC2</td><td>50</td><td>2</td><td>82</td><td>R</td><td>114</td><td>r</td></tr><tr><td>19</td><td>DC3</td><td>51</td><td>3</td><td>83</td><td>S</td><td>115</td><td>s</td></tr><tr><td>20</td><td>DC4</td><td>52</td><td>4</td><td>84</td><td>T</td><td>116</td><td>t</td></tr><tr><td>21</td><td>NAK</td><td>53</td><td>5</td><td>85</td><td>U</td><td>117</td><td>u</td></tr><tr><td>22</td><td>SYN</td><td>54</td><td>6</td><td>86</td><td>V</td><td>118</td><td>v</td></tr><tr><td>23</td><td>TB</td><td>55</td><td>7</td><td>87</td><td>W</td><td>119</td><td>w</td></tr><tr><td>24</td><td>CAN</td><td>56</td><td>8</td><td>88</td><td>X</td><td>120</td><td>x</td></tr><tr><td>25</td><td>EM</td><td>57</td><td>9</td><td>89</td><td>Y</td><td>121</td><td>y</td></tr><tr><td>26</td><td>SUB</td><td>58</td><td>:</td><td>90</td><td>Z</td><td>122</td><td>z</td></tr><tr><td>27</td><td>ESC</td><td>59</td><td>;</td><td>91</td><td>[</td><td>123</td><td></td></tr><tr><td>28</td><td>FS</td><td>60</td><td>&lt;</td><td>92</td><td>/</td><td>124</td><td></td></tr><tr><td>29</td><td>GS</td><td>61</td><td>=</td><td>93</td><td>]</td><td>125</td><td>}</td></tr><tr><td>30</td><td>RS</td><td>62</td><td>&gt;</td><td>94</td><td>^</td><td>126</td><td>·</td></tr><tr><td>31</td><td>US</td><td>63</td><td>?</td><td>95</td><td>_</td><td>127</td><td>DEL</td></tr></tbody></table><ul><li>两部分组成：<ul><li>ASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等外围设备。</li><li>ASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。<h3 id="2-5-转义字符"><a href="#2-5-转义字符" class="headerlink" title="2.5 转义字符"></a>2.5 转义字符</h3></li></ul></li><li>作用：用于表示一些不能显示出来的ASCII字符</li><li>现阶段我们常用的转义字符有：\n \ \t</li></ul><table><thead><tr><th>转义字符</th><th>含义</th><th>ASCII码值（十进制）</th></tr></thead><tbody><tr><td>\a</td><td>警报</td><td>007</td></tr><tr><td>\b</td><td>退格(BS)</td><td>008</td></tr><tr><td>\f</td><td>换页(FF)</td><td>012</td></tr><tr><td>\n</td><td>换行(LF)</td><td>010</td></tr><tr><td>\r</td><td>回车(CR)</td><td>013</td></tr><tr><td>\t</td><td>水平制表(HT)下一个TAB）</td><td>009</td></tr><tr><td>\v</td><td>垂直制表(VT)</td><td>011</td></tr><tr><td>\｜</td><td>反斜线</td><td>092</td></tr><tr><td>’</td><td>单引号</td><td>039</td></tr><tr><td>“</td><td>双引号字符</td><td>034</td></tr><tr><td>?</td><td>问号</td><td>063</td></tr><tr><td>\0</td><td>数字0</td><td>000</td></tr><tr><td>\ddd</td><td>8进制转义字符</td><td>3位8进制</td></tr><tr><td>\xhh</td><td>16进制转义字符</td><td>3位16进制</td></tr></tbody></table><h3 id="2-6-字符串型"><a href="#2-6-字符串型" class="headerlink" title="2.6 字符串型"></a>2.6 字符串型</h3><ul><li>作用：用于表示一串字符</li><li>两种风格<ul><li>C风格字符串： char 变量名[] = “字符串值”</li><li>C++风格字符串： string 变量名 = “字符串值”<blockquote><p>C++风格字符串，需要加入头文件#include<string></p></blockquote></li></ul></li></ul><h3 id="2-7-布尔类型-bool"><a href="#2-7-布尔类型-bool" class="headerlink" title="2.7 布尔类型 bool"></a>2.7 布尔类型 bool</h3><ul><li>作用：布尔数据类型代表真或假的值</li><li>bool类型只有两个值：<ul><li>true — 真（本质是1）</li><li>false — 假（本质是0）<blockquote><p>bool类型占1个字节大小</p></blockquote><h3 id="2-8-数据的输入"><a href="#2-8-数据的输入" class="headerlink" title="2.8 数据的输入"></a>2.8 数据的输入</h3></li></ul></li><li>作用：用于从键盘获取数据</li><li>关键字：cin</li><li>语法： cin &gt;&gt; 变量<h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3 运算符"></a>3 运算符</h2></li><li>作用：用于执行代码的运算</li></ul><table><thead><tr><th>运算符类型</th><th>作用</th></tr></thead><tbody><tr><td>算术运算符</td><td>四则运算</td></tr><tr><td>赋值运算符</td><td>值赋给变量</td></tr><tr><td>比较运算符</td><td>真值或假值</td></tr><tr><td>逻辑运算符</td><td>表达式的值返回真值或假值</td></tr></tbody></table><h3 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h3><ul><li>作用：用于处理四则运算</li></ul><table><thead><tr><th>运算符</th><th>术语</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>+</td><td>正号</td><td>+3</td><td>3</td></tr><tr><td>-</td><td>负号</td><td>-3</td><td>-3</td></tr><tr><td>+</td><td>加</td><td>10 + 5</td><td>15</td></tr><tr><td>-</td><td>减</td><td>10 - 5</td><td>5</td></tr><tr><td>*</td><td>乘</td><td>10 * 5</td><td>50</td></tr><tr><td>/</td><td>除</td><td>10 / 5</td><td>2</td></tr><tr><td>%</td><td>取模(取余)</td><td>10 % 3</td><td>1</td></tr><tr><td>++</td><td>前置递增</td><td>a=2; b=++a;</td><td>a=3; b=3;</td></tr><tr><td>++</td><td>后置递增</td><td>a=2; b=a++;</td><td>a=3; b=2;</td></tr><tr><td>–</td><td>前置递减</td><td>a=2; b=–a;</td><td>a=1; b=1;</td></tr><tr><td>–</td><td>后置递减</td><td>a=2; b=a–;</td><td>a=1; b=2;</td></tr></tbody></table><blockquote><p>在除法运算中，除数不能为0<br>有整型变量可以进行取模运算<br>前置递增先对变量进行++，再计算表达式，后置递增相反</p></blockquote><h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><ul><li>作用：用于将表达式的值赋给变量</li></ul><table><thead><tr><th>运算符</th><th>术语</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>=</td><td>赋值</td><td>a=2; b=3;</td><td>a=2; b=3;</td></tr><tr><td>+=</td><td>加等于</td><td>a=0; a+=2;</td><td>a=2;</td></tr><tr><td>-=</td><td>减等于</td><td>a=5; a-=3;</td><td>a=2;</td></tr><tr><td>*=</td><td>乘等于</td><td>a=2; a*=2;</td><td>a=4;</td></tr><tr><td>/=</td><td>除等于</td><td>a=4; a/=2;</td><td>a=2;</td></tr><tr><td>%=</td><td>模等于</td><td>a=3; a%2;</td><td>a=1;</td></tr></tbody></table><h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><ul><li>作用：用于表达式的比较，并返回一个真值或假值</li></ul><table><thead><tr><th>运算符</th><th>术语</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>==</td><td>相等于</td><td>4 == 3</td><td>0</td></tr><tr><td>!=</td><td>不等于</td><td>4 != 3</td><td>1</td></tr><tr><td>&lt;</td><td>小于</td><td>4 &lt; 3</td><td>0</td></tr><tr><td>&gt;</td><td>大于</td><td>4 &gt; 3</td><td>1</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>4 &lt;= 3</td><td>0</td></tr><tr><td>&gt;=</td><td>大于等于</td><td>4 &gt;= 1</td><td>1</td></tr></tbody></table><ul><li>注意：C和C++ 语言的比较运算中， “真”用数字“1”来表示， “假”用数字“0”来表示。<h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3></li><li>作用：用于根据表达式的值返回真值或假值</li></ul><table><thead><tr><th>运算符</th><th>术语</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>!</td><td>非</td><td>!a</td><td>如果a为假，则!a为真； 如果a为真，则!a为假。</td></tr><tr><td>&amp;&amp;</td><td>与</td><td>a &amp;&amp; b</td><td>如果a和b都为真，则结果为真，否则为假。</td></tr><tr><td>｜｜</td><td>或</td><td>a｜｜ b</td><td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td></tr></tbody></table><blockquote><p>总结： 真变假，假变真<br>总结：逻辑与运算符总结： 同真为真，其余为假<br>逻辑或运算符总结： 同假为假，其余为真  </p></blockquote><h2 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4 程序流程结构"></a>4 程序流程结构</h2><ul><li>三种程序运行结构：顺序结构、选择结构、循环结构<ul><li>顺序结构：程序按顺序执行，不发生跳转</li><li>选择结构：依据条件是否满足，有选择的执行相应功能</li><li>循环结构：依据条件是否满足，循环多次执行某段代码<h3 id="4-1-选择结构"><a href="#4-1-选择结构" class="headerlink" title="4.1 选择结构"></a>4.1 选择结构</h3><h4 id="4-1-1-if语句"><a href="#4-1-1-if语句" class="headerlink" title="4.1.1 if语句"></a>4.1.1 if语句</h4></li></ul></li><li>作用：执行满足条件的语句<ul><li>if语句的三种形式<ul><li>单行格式if语句—if(条件){ 条件满足执行的语句 }</li><li>多行格式if语句 —if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };</li><li>多条件的if语句多行格式if语句—if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}… else{ 都不满足执行的语句}<h4 id="4-1-2-三目运算符"><a href="#4-1-2-三目运算符" class="headerlink" title="4.1.2 三目运算符"></a>4.1.2 三目运算符</h4></li></ul></li></ul></li><li>作用： 通过三目运算符实现简单的判断</li><li>语法：表达式1 ? 表达式2 ：表达式3<blockquote><p>总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p></blockquote><h4 id="4-1-3-switch语句"><a href="#4-1-3-switch语句" class="headerlink" title="4.1.3 switch语句"></a>4.1.3 switch语句</h4></li><li>作用：执行多条件分支语句</li><li>语法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> 结果<span class="number">1</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 结果<span class="number">2</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:执行语句;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>注意1：switch语句中表达式类型只能是整型或者字符型</li><li>注意2：case里如果没有break，那么程序会一直向下执行<blockquote><p>总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间</p></blockquote></li></ul><h3 id="4-2-循环结构"><a href="#4-2-循环结构" class="headerlink" title="4.2 循环结构"></a>4.2 循环结构</h3><h4 id="4-2-1-while循环语句"><a href="#4-2-1-while循环语句" class="headerlink" title="4.2.1 while循环语句"></a>4.2.1 while循环语句</h4><ul><li>作用：满足循环条件，执行循环语句</li><li>语法：while(循环条件){ 循环语句 }<blockquote><p>解释：只要循环条件的结果为真，就执行循环语句<br>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环</p></blockquote><h4 id="4-2-2-do…while循环语句"><a href="#4-2-2-do…while循环语句" class="headerlink" title="4.2.2 do…while循环语句"></a>4.2.2 do…while循环语句</h4></li><li>作用： 满足循环条件，执行循环语句</li><li>语法： do{ 循环语句 } while(循环条件);</li><li>注意：与while的区别在于do…while会先执行一次循环语句，再判断循环条件<blockquote><p>总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件</p></blockquote><h4 id="4-2-3-for循环语句"><a href="#4-2-3-for循环语句" class="headerlink" title="4.2.3 for循环语句"></a>4.2.3 for循环语句</h4></li><li>作用： 满足循环条件，执行循环语句</li><li>语法：for(起始表达式;条件表达式;末尾循环体) { 循环语句; }<blockquote><p>注意：for循环中的表达式，要用分号进行分隔<br>总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用</p></blockquote><h4 id="4-2-4-嵌套循环"><a href="#4-2-4-嵌套循环" class="headerlink" title="4.2.4 嵌套循环"></a>4.2.4 嵌套循环</h4></li><li>作用： 在循环体中再嵌套一层循环，解决一些实际问题<h3 id="4-3-跳转语句"><a href="#4-3-跳转语句" class="headerlink" title="4.3 跳转语句"></a>4.3 跳转语句</h3><h4 id="4-3-1-break语句"><a href="#4-3-1-break语句" class="headerlink" title="4.3.1 break语句"></a>4.3.1 break语句</h4></li><li>作用: 用于跳出选择结构或者循环结构<ul><li>在switch条件语句中，作用是终止case并跳出switch</li><li>在循环语句中，作用是跳出当前的循环语句</li><li>在嵌套循环中，跳出最近的内层循环语句<h4 id="4-3-2-continue语句"><a href="#4-3-2-continue语句" class="headerlink" title="4.3.2 continue语句"></a>4.3.2 continue语句</h4></li></ul></li><li>作用：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环<blockquote><p>注意：continue并没有使整个循环终止，而break会跳出循环</p></blockquote><h4 id="4-3-3-goto语句"><a href="#4-3-3-goto语句" class="headerlink" title="4.3.3 goto语句"></a>4.3.3 goto语句</h4></li><li>作用：可以无条件跳转语句</li><li>语法： goto 标记;<blockquote><p>解释：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">goto</span> FLAG;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; endl;</span><br><span class="line">FLAG:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p></blockquote><h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3></li><li>所谓数组，就是一个集合，里面存放了相同类型的数据元素<ul><li>特点1：数组中的每个数据元素都是相同的数据类型</li><li>特点2：数组是由连续的内存位置组成的<h3 id="5-2-一维数组"><a href="#5-2-一维数组" class="headerlink" title="5.2 一维数组"></a>5.2 一维数组</h3><h4 id="5-2-1-一维数组定义方式"><a href="#5-2-1-一维数组定义方式" class="headerlink" title="5.2.1 一维数组定义方式"></a>5.2.1 一维数组定义方式</h4></li></ul></li><li>三种方式：<ul><li>数据类型 数组名[ 数组长度 ];</li><li>数据类型 数组名[ 数组长度 ] = { 值1，值2 …};</li><li>数据类型 数组名[ ] = { 值1，值2 …};<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> score2[<span class="number">10</span>] = &#123; <span class="number">100</span>, <span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> score3[] = &#123; <span class="number">100</span>,<span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名<br>总结2：数组中下标是从0开始索引</p></blockquote><h4 id="5-2-2-一维数组数组名"><a href="#5-2-2-一维数组数组名" class="headerlink" title="5.2.2 一维数组数组名"></a>5.2.2 一维数组数组名</h4></li></ul></li><li>用途：<ul><li>可以统计整个数组在内存中的长度</li><li>可以获取数组在内存中的首地址</li></ul></li><li>注意：数组名是常量，不可以赋值<blockquote><p>总结1：直接打印数组名，可以查看数组所占内存的首地址<br>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小</p></blockquote><h4 id="5-2-3-冒泡排序"><a href="#5-2-3-冒泡排序" class="headerlink" title="5.2.3 冒泡排序"></a>5.2.3 冒泡排序</h4></li><li>作用：最常用的排序算法，对数组内元素进行排序<ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。</li><li>重复以上的步骤，每次比较次数-1，直到不需要比较<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">9</span>] = &#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span> - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span> - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-二维数组"><a href="#5-3-二维数组" class="headerlink" title="5.3 二维数组"></a>5.3 二维数组</h3></li></ul></li><li>二维数组就是在一维数组上，多加一个维度。<h4 id="5-3-1-二维数组定义方式"><a href="#5-3-1-二维数组定义方式" class="headerlink" title="5.3.1 二维数组定义方式"></a>5.3.1 二维数组定义方式</h4></li><li>四种方式：<ul><li>数据类型 数组名[ 行数 ] [ 列数 ];</li><li>数据类型 数组名[ 行数 ] [ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } };</li><li>数据类型 数组名[ 行数 ] [ 列数 ] = { 数据1，数据2，数据3，数据4};</li><li>数据类型 数组名[ ] [ 列数 ] = { 数据1，数据2，数据3，数据4};</li></ul></li><li>建议：以上4种定义方式，利用第二种更加直观，提高代码的可读性<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//方式1  </span></span><br><span class="line"><span class="comment">//数组类型 数组名 [行数][列数]</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//方式2 </span></span><br><span class="line"><span class="comment">//数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</span></span><br><span class="line"><span class="keyword">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//方式3</span></span><br><span class="line"><span class="comment">//数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line"><span class="keyword">int</span> arr3[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;; </span><br><span class="line"><span class="comment">//方式4 </span></span><br><span class="line"><span class="comment">//数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line"><span class="keyword">int</span> arr4[][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p></blockquote><h4 id="5-3-2-二维数组数组名"><a href="#5-3-2-二维数组数组名" class="headerlink" title="5.3.2 二维数组数组名"></a>5.3.2 二维数组数组名</h4></li><li>查看二维数组所占内存空间</li><li>获取二维数组首地址<blockquote><p>总结1：二维数组名就是这个数组的首地址<br>总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小</p></blockquote><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3></li><li>作用：将一段经常使用的代码封装起来，减少重复代码<h3 id="6-2-函数的定义"><a href="#6-2-函数的定义" class="headerlink" title="6.2 函数的定义"></a>6.2 函数的定义</h3></li><li>5个步骤：<ul><li>1、返回值类型</li><li>2、函数名</li><li>3、参数表列</li><li>4、函数体语句</li><li>5、return 表达式</li></ul></li><li>语法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名 （参数列表）</span><br><span class="line">&#123;</span><br><span class="line">       函数体语句</span><br><span class="line">       <span class="keyword">return</span>表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-函数的调用"><a href="#6-3-函数的调用" class="headerlink" title="6.3 函数的调用"></a>6.3 函数的调用</h3></li><li>功能：使用定义好的函数</li><li>语法：函数名（参数）<blockquote><p>总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参</p></blockquote><h3 id="6-4-值传递"><a href="#6-4-值传递" class="headerlink" title="6.4 值传递"></a>6.4 值传递</h3></li><li>所谓值传递，就是函数调用时实参将数值传入给形参<blockquote><p>总结： 值传递时，形参是修饰不了实参的</p></blockquote><h3 id="6-5-函数的常见样式"><a href="#6-5-函数的常见样式" class="headerlink" title="6.5 函数的常见样式"></a>6.5 函数的常见样式</h3></li><li>4种<ul><li>无参无返</li><li>有参无返</li><li>无参有返</li><li>有参有返<h3 id="6-6-函数的声明"><a href="#6-6-函数的声明" class="headerlink" title="6.6 函数的声明"></a>6.6 函数的声明</h3></li></ul></li><li>作用： 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</li><li>函数的声明可以多次，但是函数的定义只能有一次<h3 id="6-7-函数的分文件编写"><a href="#6-7-函数的分文件编写" class="headerlink" title="6.7 函数的分文件编写"></a>6.7 函数的分文件编写</h3></li><li>作用：让代码结构更加清晰</li><li>4个步骤<ul><li>创建后缀名为.h的头文件</li><li>创建后缀名为.cpp的源文件</li><li>在头文件中写函数的声明</li><li>在源文件中写函数的定义<h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7 指针"></a>7 指针</h2><h3 id="7-1-指针的基本概念"><a href="#7-1-指针的基本概念" class="headerlink" title="7.1 指针的基本概念"></a>7.1 指针的基本概念</h3></li></ul></li><li>指针的作用： 可以通过指针间接访问内存</li><li>内存编号是从0开始记录的，一般用十六进制数字表示</li><li>可以利用指针变量保存地址</li></ul><h3 id="7-2-指针变量的定义和使用"><a href="#7-2-指针变量的定义和使用" class="headerlink" title="7.2 指针变量的定义和使用"></a>7.2 指针变量的定义和使用</h3><ul><li>指针变量定义语法： 数据类型 * 变量名；</li><li>指针变量和普通变量的区别<ul><li>普通变量存放的是数据,指针变量存放的是地址</li><li>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用<blockquote><p>总结1： 我们可以通过 &amp; 符号 获取变量的地址<br>总结2：利用指针可以记录地址<br>总结3：对指针变量解引用，可以操作指针指向的内存</p></blockquote><h3 id="7-3-指针所占内存空间"><a href="#7-3-指针所占内存空间" class="headerlink" title="7.3 指针所占内存空间"></a>7.3 指针所占内存空间</h3></li></ul></li><li>提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？<blockquote><p>总结：所有指针类型在32位操作系统下是4个字节 4×8<br>64位 8字节 8×8</p></blockquote><h3 id="7-4-空指针和野指针"><a href="#7-4-空指针和野指针" class="headerlink" title="7.4 空指针和野指针"></a>7.4 空指针和野指针</h3></li><li>空指针：指针变量指向内存中编号为0的空间</li><li>用途：初始化指针变量<blockquote><p>注意：空指针指向的内存是不可以访问的</p></blockquote></li><li>野指针：指针变量指向非法的内存空间<blockquote><p>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p></blockquote><h3 id="7-5-const修饰指针"><a href="#7-5-const修饰指针" class="headerlink" title="7.5 const修饰指针"></a>7.5 const修饰指针</h3></li><li>const修饰指针有三种情况<ul><li>const修饰指针 — 常量指针</li><li>const修饰常量 — 指针常量</li><li>const即修饰指针，又修饰常量<blockquote><p>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p></blockquote><h3 id="7-6-指针和数组"><a href="#7-6-指针和数组" class="headerlink" title="7.6 指针和数组"></a>7.6 指针和数组</h3></li></ul></li><li>作用：利用指针访问数组中元素<h3 id="7-7-指针和函数"><a href="#7-7-指针和函数" class="headerlink" title="7.7 指针和函数"></a>7.7 指针和函数</h3></li><li>作用：利用指针作函数参数，可以修改实参的值<blockquote><p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递<br>###7.8 指针、数组、函数</p></blockquote></li></ul><h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8 结构体"></a>8 结构体</h2><h3 id="8-1-结构体基本概念"><a href="#8-1-结构体基本概念" class="headerlink" title="8.1 结构体基本概念"></a>8.1 结构体基本概念</h3><ul><li>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型<h3 id="8-2-结构体定义和使用"><a href="#8-2-结构体定义和使用" class="headerlink" title="8.2 结构体定义和使用"></a>8.2 结构体定义和使用</h3></li><li>语法：struct 结构体名 { 结构体成员列表 }；</li><li>三种：<ul><li>struct 结构体名 变量名</li><li>struct 结构体名 变量名 = { 成员1值 ， 成员2值…}<blockquote><p>总结1：定义结构体时的关键字是struct，不可省略<br>总结2：创建结构体变量时，关键字struct可以省略<br>总结3：结构体变量利用操作符 ‘’.’’ 访问成员</p></blockquote><h3 id="8-3-结构体数组"><a href="#8-3-结构体数组" class="headerlink" title="8.3 结构体数组"></a>8.3 结构体数组</h3></li></ul></li><li>作用：将自定义的结构体放入到数组中方便维护</li><li>语法：struct 结构体名 数组名[元素个数] = { {} , {} , … {} }<h3 id="8-4-结构体指针"><a href="#8-4-结构体指针" class="headerlink" title="8.4 结构体指针"></a>8.4 结构体指针</h3></li><li>作用：通过指针访问结构体中的成员</li><li>利用操作符 -&gt;可以通过结构体指针访问结构体属性<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="8-5-结构体嵌套结构体"><a href="#8-5-结构体嵌套结构体" class="headerlink" title="8.5 结构体嵌套结构体"></a>8.5 结构体嵌套结构体</h3></li><li>作用： 结构体中的成员可以是另一个结构体</li></ul><h2 id="9-通讯录管理系统"><a href="#9-通讯录管理系统" class="headerlink" title="9 通讯录管理系统"></a>9 通讯录管理系统</h2><blockquote><p>创建数据+操作数据+显示数据</p></blockquote><h3 id="9-1系统需求"><a href="#9-1系统需求" class="headerlink" title="9.1系统需求"></a>9.1系统需求</h3><ul><li>添加联系人<ul><li>联系人结构</li><li>通讯录结构</li><li>main创建通讯录</li><li>封装添加联系人函数</li></ul></li><li>显示联系人</li><li>删除联系人</li><li>查找联系人</li><li>修改联系人</li><li>清空联系人</li><li>退出通讯录</li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-user_manager</title>
      <link href="/2021/06/14/study_blog/Linux/command/2021-06-14-linux_user_manager/"/>
      <url>/2021/06/14/study_blog/Linux/command/2021-06-14-linux_user_manager/</url>
      
        <content type="html"><![CDATA[<p><em>本文非原作者:<a href="https://zhuanlan.zhihu.com/p/105482468">源地址</a></em><br><em>本文只是对原文做了个人的简化与修改</em> </p><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><ul><li>根用户 root</li><li>普通用户</li><li>用户组 ：用户的分组</li></ul><h2 id="用户信息记录"><a href="#用户信息记录" class="headerlink" title="用户信息记录"></a>用户信息记录</h2><ul><li>/etc/passwd —— 管理用户UID/GID重要参数</li><li>/etc/shadow —— 管理用户密码</li><li>/etc/group —— 管理用户组相关信息</li><li>/etc/gshadow —— 管理用户组管理员相关信<h3 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h3>该文件中，每一行的存储格式为：<blockquote><p>账号名称 : 密码 : UID : GID : 用户信息说明列 : 主文件夹 : shell<br>root : x : 0 : 0 : root : /root : /bin/bash  </p></blockquote></li></ul><p>密码不显示，移至/etc/shadow中</p><h3 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h3><p>该文件中，每一行的存储格式为：</p><blockquote><p>账号名称 : 密码 : 最近改动密码的日期 : 密码不可被改变的天数 : 密码需要重新更改的天数 : 更改提醒天数 : 密码过期后账号的宽限时间 : 账号失效日期 : 保留<br>root : (字符串，此处打码) : 200 : 0 : 99999 : 7 : : :  </p></blockquote><h3 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h3><p>该文件中，每一行的存储格式为：</p><blockquote><p>用户组名称 : 用户组密码 : GID : 此用户组包含的账号名称<br>root : x : 0 : root  </p></blockquote><p>用户组密码为了设置组管理员，密码信息移至/etc/gshadow</p><h3 id="etc-gshadow"><a href="#etc-gshadow" class="headerlink" title="/etc/gshadow"></a>/etc/gshadow</h3><p>该文件中，每一行的存储格式为：</p><blockquote><p>用户组名 : 密码 : 用户组管理员账号 : 该用户组包含的账号名称<br>root : : : root  </p></blockquote><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><table><thead><tr><th>功能</th><th>命令</th><th>使用</th><th>remark</th></tr></thead><tbody><tr><td>新增用户</td><td>useradd</td><td>useradd [option] [usrname]</td><td>/etc/login.defs 、/etc/default/useradd</td></tr><tr><td></td><td>adduser</td><td></td><td>更偏程序化一点，会自动创建家目录等</td></tr><tr><td>设置密码</td><td>passwd</td><td>passwd [options] [username]</td><td>与useradd类似</td></tr><tr><td>改变用户信息</td><td>usermod</td><td>usermod [options] [username]</td><td>修改保存在/etc/passwd中的信息</td></tr><tr><td>删除用户</td><td>userdel</td><td>userdel [options] [username]</td><td>删除用户及信息（测试时家目录未删除}</td></tr><tr><td></td><td>deluser</td><td></td><td>和adduser类似</td></tr></tbody></table><ul><li>用户在创建的时候会根据login.defs 和useradd来默认指定，如果不添加控制的话</li><li>/etc/default/useradd<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GROUP = 100                            <span class="comment"># 默认的用户组  </span></span><br><span class="line">HOME = /home                           <span class="comment"># 默认的主文件夹所在目录  </span></span><br><span class="line">INACTIVE = -1                          <span class="comment"># 密码失效日  </span></span><br><span class="line">EXPIRE =                               <span class="comment"># 账号失效日  </span></span><br><span class="line">SHELL = /bin/shell                     <span class="comment"># 默认shell  </span></span><br><span class="line">SKEL = /etc/skel                       <span class="comment"># 用户主文件夹的内容数据参考目录  </span></span><br><span class="line">CREATE_MAIL_SPOOL = yes                <span class="comment"># 是否创建邮件信箱  </span></span><br></pre></td></tr></table></figure></li><li>/etc/login.defs  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PASS_MAX_DAYS       99999           <span class="comment"># 多久必须重设密码（天）  </span></span><br><span class="line">PASS_MIN_DAYS       0               <span class="comment"># 距上次修改密码多久不可重设密码（天）  </span></span><br><span class="line">PASS_MIN_LEN        5               <span class="comment"># 密码最短的字符长度  </span></span><br><span class="line">PASS_WARN_AGE       7               <span class="comment"># 距离多少天过期会报警提示  </span></span><br><span class="line">UID_MIN             500             <span class="comment"># 创建用户的UID默认最小值  </span></span><br><span class="line">UID_MAX             60000           <span class="comment"># 创建用户的UID上限  </span></span><br><span class="line">GID_MIN             500             <span class="comment"># 创建用户的GID默认最小值  </span></span><br><span class="line">GID_MAX             60000           <span class="comment"># 创建用户的GID上限  </span></span><br><span class="line">USERGROUPS_ENAB     yes             <span class="comment"># 删除用户时是否删除初始用户组（组内不再有其他成员）  </span></span><br><span class="line">MD5_CRYPT_ENAB      yes             <span class="comment"># 密码是否经过MD5加密  </span></span><br></pre></td></tr></table></figure></li></ul><h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><table><thead><tr><th>功能</th><th>命令</th><th>使用</th><th>remark</th></tr></thead><tbody><tr><td>添加用户组</td><td>groupadd</td><td>groupadd [options] [groupname]</td><td>与useradd类似，不需要设置密码</td></tr><tr><td></td><td>addgroup</td><td></td><td>与adduser类似</td></tr><tr><td>修改用户组</td><td>groupmod</td><td>groupmod [options] [groupname]</td><td>修改group相关参数，不建议修改gid</td></tr><tr><td>删除用户组</td><td>groupdel</td><td>groupdel [options] [groupname]</td><td>删除前需要保证无任何用户以它为默认组</td></tr><tr><td></td><td>delgroup</td><td></td><td>与deluser相似</td></tr></tbody></table><h2 id="身份切换-sudo-su"><a href="#身份切换-sudo-su" class="headerlink" title="身份切换 sudo su"></a>身份切换 sudo su</h2><ul><li><p>su</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> su [options] [username]</span><br><span class="line">options：</span><br><span class="line">-：代表使用 login-shell 的变量文件读取方式来登录系统</span><br><span class="line">-l：同上</span><br><span class="line">-m：表示使用当前的环境设置，而不读取新用户的配置文件</span><br><span class="line">-c：仅进行一次命令，执行完后直接回到目前的用户身份</span><br></pre></td></tr></table></figure></li><li><ul><li>若空默认为root用户  </li><li>“su -” 表示切换身份的同时读取目标用户的 login-shell ，通常建议使用这一方式切换身份。  </li><li>另外，在普通用户切换到 root 用户时，需要 root 用户的登录密码，才能成功切换。这里又涉及到一个安全问题，如何让指定的普通用户具备 root 权限的同时，不让其知道 root 的登录密码呢？这就需要使用 sudo 命令了。</li></ul></li><li><p>sudo </p><ul><li>普通用户可以通过 sudo 命令，使用 root 用户权限来执行命令。</li><li>该用户需要在 /etc/sudoers文件里面</li></ul></li><li><p>/etc/sudoers<br><img src="https://pic4.zhimg.com/80/v2-828506b937e3242327cdd9459ed59b07_720w.jpg" alt="sudoers"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#图中第一行，表示可执行 sudo 的单个用户白名单</span></span><br><span class="line">root              ALL=(ALL:ALL)                                         ALL</span><br><span class="line">用户账号          登录者来源主机名=(可切换身份：身份所在用户组)           可执行命令</span><br><span class="line"><span class="comment">#图中第二行，表示可执行 sudo 的用户组白名单</span></span><br><span class="line">root              ALL=(ALL:ALL)                                         ALL</span><br><span class="line">用户账号          登录者来源主机名=(可切换身份：身份所在用户组)           可执行命令</span><br></pre></td></tr></table></figure></li><li><p>例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testuser            ALL=(ALL:ALL)               ALL</span><br><span class="line">testuser            ALL=(root:root)             ALL</span><br><span class="line">testuser            ALL=(root:root)             /usr/bin/passwd</span><br></pre></td></tr></table></figure><h2 id="查询用户信息"><a href="#查询用户信息" class="headerlink" title="查询用户信息"></a>查询用户信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id &lt;user&gt;                           <span class="comment"># 展示指定user的UID、GID、用户组信息等，默认为当前有效用户</span></span><br><span class="line">who am i                            <span class="comment"># 等同于 who -m，仅显示当前登录用户相关信息</span></span><br><span class="line">whoami                              <span class="comment">#   仅显示当前有效用户的用户名</span></span><br><span class="line">w                                   <span class="comment"># 展示当前正在登录主机的用户信息及正在执行的操作</span></span><br><span class="line">who                                 <span class="comment"># 展示当前正在登录主机的用户信息</span></span><br><span class="line">last &lt;user&gt;                         <span class="comment"># 展示指定用户的历史登录信息，默认为当前有效用户</span></span><br><span class="line">lastlog -u &lt;user&gt;                   <span class="comment"># 展示指定用户最近的一次登录信息，默认显示所有用户</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> user </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>server-ftp</title>
      <link href="/2021/06/13/study_blog/Linux/server/2021-6-13-server_ftp/"/>
      <url>/2021/06/13/study_blog/Linux/server/2021-6-13-server_ftp/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><blockquote><p>centos-8<br>server:vsftp<br>client:koder 、Fe file explore、(能提供链接ftp 的软件都可）</p></blockquote><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install -y vsftp</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote><p>配置文件在 /etc/vsftpd/<br>/etc/vsftpd/vsftpd.conf</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nvim /etc/vsftp/vsftpd.conf</span><br><span class="line"></span><br><span class="line">anonymous_enable=NO <span class="comment">#不能访客访问</span></span><br><span class="line">local_enable=YES <span class="comment">#本地用户登录</span></span><br><span class="line">write_enable=YES <span class="comment">#准许写</span></span><br><span class="line">listen_ipv6=NO <span class="comment"># 关闭ipv6</span></span><br><span class="line">listen=YES <span class="comment">#ipv4监听打开</span></span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start vsftpd <span class="comment">#开启vsftp服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> vsftp <span class="comment">#每一次开机自启动服务</span></span><br><span class="line"><span class="comment">#在阿里云控制端中修改安全组访问（开放端口20,21）</span></span><br></pre></td></tr></table></figure><h2 id="客户端（client）端"><a href="#客户端（client）端" class="headerlink" title="客户端（client）端"></a>客户端（client）端</h2><h3 id="koder"><a href="#koder" class="headerlink" title="koder"></a>koder</h3><ul><li>填写相应的ip，端口，用户名即可。链接模式哪里选择Active（port）模式<br><img src="https://img-blog.csdnimg.cn/20210613155045923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Nzk3MDg2,size_16,color_FFFFFF,t_70#pic_center=400*400" alt="koder"><h3 id="Fe-file-explore"><a href="#Fe-file-explore" class="headerlink" title="Fe file explore"></a>Fe file explore</h3></li><li> 交互要人性化一点，但pro版收费很烦<br><img src="https://img-blog.csdnimg.cn/20210613155130426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Nzk3MDg2,size_16,color_FFFFFF,t_70#pic_center" alt="fe"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ftp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>server-jupyter_notebook</title>
      <link href="/2021/06/12/study_blog/Linux/server/2021-06-12-server-jupyter_notebook/"/>
      <url>/2021/06/12/study_blog/Linux/server/2021-06-12-server-jupyter_notebook/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><blockquote><p>服务器系统 centos-8<br>python3</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip3 install jupyter</span><br><span class="line">jupyter notebook --generate-config  <span class="comment"># 这里推荐重新创建非root用户下</span></span><br><span class="line"></span><br><span class="line">python3</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from notebook.auth import passwd</span><br><span class="line">passwd() #然后输入你想要设置的密码，并记录下生成的密钥</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nvim ～/.jupyter/jupyter_notebook_config.py  </span><br><span class="line">c.NotebookApp.ip = <span class="string">&#x27;*&#x27;</span> <span class="comment">#可以访问的ip，*为所有</span></span><br><span class="line">c.NotebookApp.open_browser = False <span class="comment">#是否打开浏览器</span></span><br><span class="line">c.NotebookApp.notebook_dir = <span class="string">&#x27;/home/[user]/jupyter&#x27;</span> <span class="comment">#这里推荐在所在目录下创建一个目录来放</span></span><br><span class="line">c.NotebookApp.port = 8888 <span class="comment">#监听的端口，默认是8888</span></span><br><span class="line">c.NotebookApp.password = <span class="string">&#x27;[*]&#x27;</span>  <span class="comment">#[*]中替换上面的密钥</span></span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook &amp; <span class="comment">#后台运行。</span></span><br><span class="line"><span class="comment">#在阿里云控制端中修改安全组访问（开放相应的端口）即可访问</span></span><br><span class="line"><span class="comment">#在浏览器中中输入</span></span><br><span class="line"><span class="comment"># ip：8888   </span></span><br><span class="line"><span class="comment">#以访问</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/feilong_csdn/article/details/90677233">参考博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> jupyter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习_合作方式</title>
      <link href="/2021/05/16/study_blog/Git/2021-05-16-git_cooperation/"/>
      <url>/2021/05/16/study_blog/Git/2021-05-16-git_cooperation/</url>
      
        <content type="html"><![CDATA[<h1 id="使用git和别人合作"><a href="#使用git和别人合作" class="headerlink" title="使用git和别人合作"></a>使用git和别人合作</h1><blockquote><p>个人感觉以下两种方法比较适合<br>1，两个人合作；2，多人合作。  </p></blockquote><h2 id="1-两个人合作"><a href="#1-两个人合作" class="headerlink" title="1.两个人合作"></a>1.两个人合作</h2><p>思路：建立两个remote源<br>remote:  </p><ul><li>origin<ul><li>默认，自带，指向自己的仓库</li></ul></li><li>sync<ul><li>指向队友的仓库  </li></ul></li></ul><p>工作流: </p><ul><li>1.双方开发不同模块<ul><li>仅需在需要[调试]或者[推送到自己仓库]之前pull一下sync源，以保证同步。</li></ul></li><li>2.双方开发同一模块<ul><li>在每次开始前同步sync源，以确保同步。有更新之后及时推送origin<br>优点：全程可以保持不去云端操作；<br>缺点：仅适合两个人</li></ul></li></ul><h2 id="2-多人合作"><a href="#2-多人合作" class="headerlink" title="2.多人合作"></a>2.多人合作</h2><p>思路：fork别人的项目，以pull request方式提交<br>remote:</p><ul><li>origin<ul><li>默认，自带，指向自己的仓库</li></ul></li><li>sync<ul><li>指向队友的仓库  </li></ul></li></ul><p>工作流：</p><ul><li>sync同步项目</li><li>每次有更新之后提交到自己的仓库，然后发pr（pull request）。然后等待主仓库合并<br>优点：多人同时开发；<br>缺点：过程相对繁琐一些</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker_本地搭建jekyll服务调试</title>
      <link href="/2021/05/02/study_blog/docker/2021-05-02-docker_with_jekyll/"/>
      <url>/2021/05/02/study_blog/docker/2021-05-02-docker_with_jekyll/</url>
      
        <content type="html"><![CDATA[<h1 id="使用docker在本地搭建jekyll服务调试"><a href="#使用docker在本地搭建jekyll服务调试" class="headerlink" title="使用docker在本地搭建jekyll服务调试"></a>使用docker在本地搭建jekyll服务调试</h1><blockquote><p>作者使用的本机是manjaro，在安装启动jekyll调试过程中一直报错，无奈头发有点多，所以选择偷懒的方式<br>使用docker在本地搭建jekyll服务调试，以避免依赖等错误</p></blockquote><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu</span><br><span class="line">docker run -it ubuntu -v /home/[user_name]/[jekyll_project]:/home/mount ubuntu</span><br><span class="line"><span class="comment">#以下在ubuntu镜像中</span></span><br><span class="line">apt-get -qqy update <span class="comment">#更新源</span></span><br><span class="line">sudo apt-get -qqy install ruby-full build-essential zlib1g-dev <span class="comment">#Install Ruby and other prerequisites:</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;# Install Ruby Gems to ~/gems&#x27;</span> &gt;&gt; ~/.bashrc <span class="comment">#add environment variables </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export GEM_HOME=&quot;$HOME/gems&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$HOME/gems/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc </span><br><span class="line">gem install jekyll bundler <span class="comment">#Finally, install Jekyll and Bundler:</span></span><br><span class="line"></span><br><span class="line">jekyll new my-awesome-site <span class="comment">#quick start</span></span><br><span class="line"><span class="built_in">cd</span> my-awesome-site</span><br><span class="line">bundle <span class="built_in">exec</span> jekyll serve</span><br><span class="line"><span class="comment"># =&gt; Now browse to http://localhost:4000</span></span><br><span class="line"><span class="comment"># 以上来自jekyll官方的安装过程</span></span><br><span class="line"><span class="comment">#以上过程之后访问主机的localhost：4000还是dockerip:4000 都是无法成功的。</span></span><br><span class="line"><span class="comment">#原因是前者没有在启动时映射端口，后者防火墙默认屏蔽除本机以外的访问。</span></span><br><span class="line"><span class="comment">#修改如下</span></span><br><span class="line"><span class="comment">#1.</span></span><br><span class="line">docker run -it ubuntu -p 4000:4000 -v /home/[user_name]/[jekyll_project]:/home/mount ubuntu</span><br><span class="line"><span class="comment">#通过映射端口然后访问localhost:4000可以访问</span></span><br><span class="line"><span class="comment">#2.</span></span><br><span class="line">bundle <span class="built_in">exec</span> jekyll serve --host=0.0.0.0 <span class="comment">#在docker容器中设置任何ip地址可访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后保存镜像，以供以后使用。在本机中</span></span><br><span class="line">docker commit [container_name] jekyll</span><br><span class="line"><span class="comment">#下一次本地调试时</span></span><br><span class="line">docker run -it ubuntu -p 4000:4000 -v /home/[user_name]/[jekyll_project]:/home/mount jekyll</span><br><span class="line"><span class="built_in">cd</span> /home/mount</span><br><span class="line">jekyll s --host=0.0.0.0</span><br><span class="line"><span class="comment">#都需要添加-host参数以让其他ip可以访问</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习-基础操作</title>
      <link href="/2021/04/25/study_blog/Git/2021-04-25-git_base/"/>
      <url>/2021/04/25/study_blog/Git/2021-04-25-git_base/</url>
      
        <content type="html"><![CDATA[<h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><ul><li>git init  <pre><code> 创建一个仓库  </code></pre></li></ul><h2 id="file-base-command"><a href="#file-base-command" class="headerlink" title="file_base_command"></a>file_base_command</h2><ul><li>git add  <ul><li>1.添加一个文件成索引状态  </li><li>2.把修改过的文件提交到暂存区</li></ul></li><li>git rm  <ul><li>移除一个文件的索引状态</li></ul></li><li>git diff  <ul><li>比较源文件 和目标文件的修改</li></ul></li><li>git log  <ul><li> 显示提交状态 方式较多，format可以定制</li></ul></li><li>git commit  <ul><li> 把暂存区的文件提交到git仓库里面</li><li> m选项添加message</li><li>amend 选项修复上一次的提交</li></ul></li></ul><h3 id="file-status"><a href="#file-status" class="headerlink" title="file status"></a>file status</h3><table><thead><tr><th>索引态(traked)</th><th>-</th></tr></thead><tbody><tr><td></td><td>修改态(Modified)</td></tr><tr><td></td><td>暂存态(Staged)</td></tr><tr><td></td><td>提交态(Unmodified)</td></tr><tr><td>未索引态(Untracked)</td><td></td></tr></tbody></table><p>文件仓库中的文件有索引和未索引之分（也就是是否被git追踪修改）  </p><p><strong>文件之间的状态变化及操作</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant Untracked</span><br><span class="line">participant Unmodified</span><br><span class="line">participant Modified</span><br><span class="line">participant Staged</span><br><span class="line">Untracked -&gt;&gt; Staged: add  [ file ]</span><br><span class="line">Unmodified--&gt;&gt;Modified: edit file</span><br><span class="line">Unmodified--x Untracked: rm [ file ]</span><br><span class="line">Modified-&gt;&gt; Staged: add [file ]</span><br><span class="line">Staged-&gt;&gt; Unmodified: commit -m &quot; commit info&quot;</span><br><span class="line">Note right of Staged: 实线往更稳定的状态的操作，虚线更不稳定&lt;br/&gt;带❎移除追踪记录(个人解释，仅供参考）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="branch-git-杀手锏）"><a href="#branch-git-杀手锏）" class="headerlink" title="branch(git 杀手锏）"></a>branch(git 杀手锏）</h2><ul><li>git branch<ul><li> 后面跟分支名 新增一个分支（其实是添加一个指针） </li></ul></li><li>git checkout</li><li>git checkout -b<ul><li> 切换到一个分支里面区 b选项可以新建一个分支</li></ul></li><li>git merge<ul><li> 合并两个分支</li></ul></li></ul><p><strong>假设有两个分支Master ,dev,其余的为一次次的提交（镜像）.那么分支树大概如下</strong><br><strong>每个分支有不同的指针指向，HEAD指针指向当前分支的指针</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph RL</span><br><span class="line">    98ca9 --&gt; 34ac2 </span><br><span class="line">    34ac2 --&gt; d30ab </span><br><span class="line">    c269e --&gt; 98ca9 </span><br><span class="line">    87ab2 --&gt; 98ca9 </span><br><span class="line">    M&#123;Master&#125; ==pointer==&gt; 87ab2 </span><br><span class="line">    H&#123;head&#125; ==pointer==&gt; M </span><br><span class="line">    N&#123;dev&#125; ==pointer==&gt; c269e </span><br></pre></td></tr></table></figure><h3 id="git目录下的结构"><a href="#git目录下的结构" class="headerlink" title="git目录下的结构"></a>git目录下的结构</h3><p>├── .git<br>│   ├── HEAD<br>│   ├── branches<br>│   ├── config<br>│   ├── description<br>│   ├── hooks<br>│   ├── info<br>│   ├── objects<br>│   └── refs<br>└── readme<br>work area :当前目录<br>git repository :.git目录=仓库<br>git stage : 暂存  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant workarea</span><br><span class="line">participant gitstage</span><br><span class="line">participant gitrepository</span><br><span class="line">workarea-&gt;&gt; gitstage : add  [ file ]</span><br><span class="line">gitstage-&gt;&gt; gitrepository: commit -m  [file]</span><br><span class="line">gitrepository-&gt;&gt; workarea: 每次载入会从repository之中载入</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对虚拟机的思考</title>
      <link href="/2021/04/24/study_blog/Linux/2021-04-24-virtual/"/>
      <url>/2021/04/24/study_blog/Linux/2021-04-24-virtual/</url>
      
        <content type="html"><![CDATA[<h2 id="为啥要用虚拟机？"><a href="#为啥要用虚拟机？" class="headerlink" title="为啥要用虚拟机？"></a>为啥要用虚拟机？</h2><pre><code>1.没钱买更多设备的情况下，安装虚拟机不就成了更适合的选择了。 2.想折腾计算机又怕搞坏计算机（都是没钱惹得祸）。3方便配置编程环境，方便配置编程环境，方便配置编程环境（重要的事情说三遍）4，响应国家的号召呐。虽然没用国产的UOS,但大同小异，都是对开源的支持哈</code></pre><h2 id="怎么安装虚拟机？"><a href="#怎么安装虚拟机？" class="headerlink" title="怎么安装虚拟机？"></a>怎么安装虚拟机？</h2><pre><code>组成：虚拟机的环境+系统镜像包虚拟机的环境：主流的选择vmware，界面友好，功能强大，可以多开。当然，我选virtualbox。主要是对开源的支持呐。（手动狗头，主要是穷和懒，vmware收费呐，网上有许多破解教程，也有个人版。如果觉得virtualbox不太好用，值得一试）系统镜像包：虽然大多人的第一个linux系统是ubuntu,但是呢，人生苦短，我选manjaro（继续狗头）</code></pre><h2 id="安装的过程？"><a href="#安装的过程？" class="headerlink" title="安装的过程？"></a>安装的过程？</h2><pre><code>1.新建一个虚拟机：在virtualbox中点击新建，然后点点点就行，这里要注意的几点是，推荐运行内存选择自己物理主机的一半（eg,如果自己的机器是8g,那么选择4g），存储内存建议选择40G及以上（选择放在固态硬盘上，如果放在机械盘上，可能体验并不好）其他的随心选择就行，错了顶多删除再来一次。2.安装：点击启动虚拟机，然后它会让你选择一个镜像包，这里选择下载好的后缀为.ISO的那个文件。然后一路点回车  来到  安装界面，语言选中文，地区选上海  继续一路随心选。直到安装方式那里，推荐选择抹除硬盘安装（这里的硬盘是你上面新建的虚拟40g硬盘，swap那里推荐选择你运行内存的两倍（例如  如果上面是4G 那么选择8g）3。安装进度条结束之后，选择重启然后选择确定。然后点击右下角那里有个光碟标志的东西，点击移除硬盘。然后你就进入安装好的系统了。4.设置个人信息：第一次进入系统，有没有一种第一次拿到windows10进入的感觉？只是这里少了小那，不过一样，随心设置过去就好。5.屏幕变成和实体机一样大小：这里能够看到屏幕惨不忍睹，又小又不好看。点击virtualbox的机器那里，然后安装增强工具，按照它的提示走，安装好之后，终端里面最后一句显示的是enjoy ***** 这时候增强工具就算安装好了，点击窗口大小，然后全屏，一个和物理实体机的显示就出来了。</code></pre><h2 id="安装开发环境（eg-java）"><a href="#安装开发环境（eg-java）" class="headerlink" title="安装开发环境（eg.java）"></a>安装开发环境（eg.java）</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pacman-mirrors -i -c China -m rank <span class="comment">#换镜像源，选择延迟最低的</span></span><br><span class="line">pacman -Syyu <span class="comment">#强制更新软件</span></span><br><span class="line">pacman -S yay base-devel <span class="comment">#安装aur个人软件仓库和基本开发工具</span></span><br><span class="line">pacman -S jre-openjdk-headless jre-openjdk jdk-openjdk openjdk-doc openjdk-src <span class="comment">#安装java最新版，分别是jre jdk和文档，如果要安装java8在每个安装包后面按tab键  出来补全的选择8就好。</span></span><br><span class="line">pacman -S eclipse-ecj <span class="comment">#安装eclipse.其他软件同理  这里java的ide还推荐vs code（把安装那里换成code,然后就一键安装了，编辑器推荐vim,不过对新手不友好。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果需要安装中文输入法</span></span><br><span class="line">yay -S fcitx5 fcitx5-qt fcitx5-gtk fcitx5-qt4 fcitx5-chinese-addons fcitx5-configtool fcitx5-material-color</span><br><span class="line"><span class="comment">#fcitx5 :fcitx5引擎本体</span></span><br><span class="line"><span class="comment">#fcitx5-qt fcitx5-gtk fcitx5-qt4 ：对各种图形界面的支持模块</span></span><br><span class="line"><span class="comment">#fcitx5-chinese-addons ：fcitx5的中文输入法插件</span></span><br><span class="line"><span class="comment">#fcitx5-configtool：fcitx5的图形配置工具</span></span><br><span class="line"><span class="comment">#fcitx5-material-color ：主题美化</span></span><br><span class="line">vim ~/.xprofile</span><br><span class="line">|<span class="built_in">export</span> GTK_IM_MODULE=fcitx</span><br><span class="line">|<span class="built_in">export</span> QT_IM_MODULE=fcitx</span><br><span class="line">|<span class="built_in">export</span> XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtualbox </tag>
            
            <tag> vmware </tag>
            
            <tag> manjaro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>像使用vim一样使用电脑</title>
      <link href="/2021/04/21/think_life/2021-04-21-keybord-vim/"/>
      <url>/2021/04/21/think_life/2021-04-21-keybord-vim/</url>
      
        <content type="html"><![CDATA[<h2 id="operate-computer-as-vim"><a href="#operate-computer-as-vim" class="headerlink" title="operate computer as vim"></a>operate computer as vim</h2><p><img src="https://img-blog.csdnimg.cn/20210421235012709.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Nzk3MDg2,size_16,color_FFFFFF,t_70" alt="keychron-k6"></p><blockquote><p>在收到瑶哥键盘的一个月后，开发了一套类vim快捷键,适应了这种懒模式，特此记录一波<br>在使用dwm的途中，手指越来越不想离开主键位，去够键盘的一些边角区域<br>在有了K6之后，这样的情况扩大了，实在不想去够几个重要且有边角的键（esc，方向键，fn1，2）<br>于是设计了这一套键位，让整个电脑的操作逻辑都vim化了。  </p></blockquote><p><strong>思路大概如下</strong><br><em>启发于vim的使用</em></p><h2 id="四种模式"><a href="#四种模式" class="headerlink" title="四种模式"></a>四种模式</h2><ul><li><p>普通模式（normal mode）</p><ul><li>[key] 的键入模式（所见即所得，键入a就是a  </li></ul></li><li><p>扩展模式（extension mode）</p><ul><li>shift+[key] 的模式，这个映射没有修改，一般键入一些字符等等（和正常的一样）</li></ul></li><li><p>视图模式（view mode）</p><ul><li>Mod+[key] 的键入，这里使用的是dwm对视图的管理，我这里mod键设置的是Alt<br>eg:  <table><thead><tr><th>键位</th><th>功能</th></tr></thead><tbody><tr><td>Mod+shift+enter</td><td>创建终端</td></tr><tr><td>Mod+c</td><td>打开chromium浏览器</td></tr><tr><td>Mod+m</td><td>全屏/平铺/浮动模式</td></tr><tr><td>Mod+j/k</td><td>窗口的上下切换</td></tr><tr><td>….这里用的是dwm的，不作展开</td><td></td></tr></tbody></table></li></ul></li><li><p>导航模式（navigation mode）</p><ul><li>Swith+[key] 的键入，是本文的重点，使用xmodmap来修改键位映射，多出了一种模式，更懒的摆放双手，<br>Swith键设置的是Caps_lock键，原先的Caps_lock 变成shift+caps_lock</li></ul><table><thead><tr><th>键位</th><th>功能</th></tr></thead><tbody><tr><td>Swith + h/j/k/l</td><td>方向键左/下/上/右</td></tr><tr><td>Swith + 1/2/3/4/5/6/7/8/9/0/-/=</td><td>对应F1-F12</td></tr><tr><td>Swith = esc</td><td>Switch键单点映射esc键，组合是导航功能</td></tr></tbody></table><p>   优势：创新主要在四个方向键的绑定和单点映射esc键哪里，真的是越用越爽，很多时候都会忘了左上角的esc键和右下角的方向键。作为一个vimer，在vim当中可以不用切换普通模式达到轻度移动，和快速的esc键有了很好的体验</p></li></ul><h2 id="对于键盘的一些小思考"><a href="#对于键盘的一些小思考" class="headerlink" title="对于键盘的一些小思考"></a>对于键盘的一些小思考</h2><ul><li>于我看来，以前的普通款的108键盘已经很少看到（这句话之适用于自己身边的人）</li><li>大多买键盘偏好于87键/79键，去掉了数字键和一些使用频率十分少的功能键，感觉除了便捷一方面之外，可能还有不愿意突然够老远去按数字键，所以首当其冲的它被砍掉了</li><li>有少一部分人选择了61/68键，我属于其中一员，于我而言，这带给我的最大变化不是携带便捷，而是一种手不离开主键位的偷懒  </li></ul><h2 id="enjoy-vim"><a href="#enjoy-vim" class="headerlink" title="enjoy vim"></a>enjoy vim</h2><p><a href="https://wiki.archlinux.org/index.php/Xmodmap">xmodmap参考</a><br><a href="https://wiki.archlinux.org/index.php/Xorg/Keyboard_configuration#One-click_key_functions">xcape参考</a><br><img src="https://img-blog.csdnimg.cn/20210421235127879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Nzk3MDg2,size_16,color_FFFFFF,t_70" alt="scre"></p>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> xmodmap </tag>
            
            <tag> 键位映射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux命令思考--ln</title>
      <link href="/2021/04/20/study_blog/Linux/command/2021-04-20-ln_think/"/>
      <url>/2021/04/20/study_blog/Linux/command/2021-04-20-ln_think/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>tldr ln  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先来看一下tldr里面极短的命令解释，两个用法</span></span><br><span class="line"><span class="comment"># ln file filehardlink</span></span><br><span class="line"><span class="comment"># ln -s file filesymblink</span></span><br><span class="line"><span class="comment">#最后说一下。好像我刚刚讲错了。带s选项的是软链接，</span></span><br><span class="line"><span class="comment">#快捷方式偏软链接一些</span></span><br><span class="line">  Creates links to files and directories.</span><br><span class="line"></span><br><span class="line">  - Create a symbolic link to a file or directory:</span><br><span class="line">    ln -s path/to/file_or_directory path/to/symlink</span><br><span class="line"></span><br><span class="line">  - Create a hard link to a file:</span><br><span class="line">    ln path/to/file path/to/hardlink</span><br></pre></td></tr></table></figure><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello &gt; a.txt<span class="comment">#创建文件a.txt并写入hello</span></span><br><span class="line">$ ln a.txt a_hardlink <span class="comment">#建立硬链接</span></span><br><span class="line">$ ln -s a.txt a_sym<span class="comment">#建立软链接</span></span><br><span class="line"></span><br><span class="line">$ ll <span class="comment">#查看目录下文件的链接关系 及大小</span></span><br><span class="line">$ cat a.txt </span><br><span class="line">$ cat a_hardlink</span><br><span class="line">$ cat a_sym <span class="comment">#查看三个文件。内容一致</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;aaaaaaaaaa&quot;</span>&gt;&gt;a_hardlink <span class="comment">#添加内容。添加到文件后面</span></span><br><span class="line"></span><br><span class="line">$ ll <span class="comment">#查看目录下文件的链接关系 及大小 ，发现硬链接随之改变并与原文件等大，但软链接大小不变</span></span><br><span class="line">$ cat a.txt </span><br><span class="line">$ cat a_hardlink</span><br><span class="line">$ cat a_sym <span class="comment">#查看三个文件。内容一致</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上是ln的实践，其实-s的软链接创建的是一个目录导向文件，就有点类似windows的快捷方式 ，windows的快捷方式是.link的文件。打开这两个文件会发现其实。内容是目录导向，只是在系统中。用cat查看的时候能够默认导过去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fdisk -l</span></span><br></pre></td></tr></table></figure><p>![截屏2020-12-13 下午8.48.27](/Users/we/Library/Application Support/typora-user-images/截屏2020-12-13 下午8.48.27.png)</p><p>解释一下：命令是硬盘管理，l选项是我一致认为是详情的意思，</p><p>第一行 指明有一个硬盘 地址是 /dev/sda （<del>linux默认的主地址，也就是系统盘地址，非系统盘是sdb，sdc这些</del>）</p><p><del>这一块就相当于一块实际的固态/机械硬盘。</del></p><p>文件系统（<del>比如fat32，ext4</del>）针对的对象是分区（<del>单词是p开头的来着</del>）</p><p>接下来几行是这块硬盘的一些属性</p><p>一直到Device这里，这里描述的是这块硬盘有几个分区，里面都有啥</p><p>如果这块有</p><ul><li><p>分区1 sda1 大小是200m </p></li><li><p>分区2 sda2 大小是200m </p></li><li><p>分区3 sda3 大小是35G</p><p>（<del>类型都是linux？，这个好像显示的不细致，我记得第一个分区类型是fat32，grub分区，第二块类型是ext4，boot分区，第三块类型是ext4，data分区</del>)</p></li></ul><p>比如这里如果插一块8G的U盘</p><p>![截屏2020-12-13 下午9.11.53](/Users/we/Documents/截屏2020-12-13 下午9.11.53.png)</p><p>可以看到它没有分区。这是一块没有灵魂的的U盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk /dev/sdb <span class="comment">#给磁盘分区</span></span><br><span class="line">$ mkfs.ext4 /dev/sdb1 <span class="comment">#给磁盘的分区1格式化成你想要的格式，这里选ext4</span></span><br></pre></td></tr></table></figure><p>![截屏2020-12-13 下午9.14.40](/Users/we/Documents/截屏2020-12-13 下午9.14.40.png)</p><p><strong>附录：🤮，请注意，虚拟机里面对硬盘的支持不是很好,容易报错，这是我试了几次才想起来以前看到过这么一条提示，🤢恶心到我了，如果不格式化之前mount挂在是会报错的，但如果在虚拟机中格式化了挂载如果不成功（别怀疑，那不是你的问题，那是虚拟的问题）</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> virtualbox </tag>
            
            <tag> command </tag>
            
            <tag> ln </tag>
            
            <tag> tldr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LAMP 环境 和phpmyadmin</title>
      <link href="/2021/04/11/study_blog/Linux/LAMP/2021-04-11-LAMP_phpmyadmin/"/>
      <url>/2021/04/11/study_blog/Linux/LAMP/2021-04-11-LAMP_phpmyadmin/</url>
      
        <content type="html"><![CDATA[<h2 id="LAMP"><a href="#LAMP" class="headerlink" title="LAMP"></a>LAMP</h2><pre><code>- L 选择manjaro（centos更适合做服务器）- A apche- M mysql （参考上前面）- P php</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pacman -S mysql php php7 php7-fpm php7-apche</span><br><span class="line"><span class="comment">#打开文件/etc/httpd/conf/httpd.conf</span></span><br><span class="line"><span class="comment">#注释掉</span></span><br><span class="line">LoadModule mpm_event_module modules/mod_mpm_event.so</span><br><span class="line"><span class="comment">#然后取消掉这一行的注释，一般在前一的后面</span></span><br><span class="line">LoadModule mpm_prefork_module modules/mod_mpm_prefork.so</span><br><span class="line"><span class="comment"># 把下面两行放在LoadModule模块的后面</span></span><br><span class="line">LoadModule php_module modules/libphp.so</span><br><span class="line">AddHandler php-script .php</span><br><span class="line"><span class="comment"># 把下面这个放在Include模块的后面</span></span><br><span class="line">Include conf/extra/php_module.conf</span><br><span class="line"><span class="comment">#最后需要重启httpd服务</span></span><br></pre></td></tr></table></figure><h3 id="测试php是否安装成功"><a href="#测试php是否安装成功" class="headerlink" title="测试php是否安装成功"></a>测试php是否安装成功</h3><p>在/srv/http/中建立一个php文件 写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>打开如果能显示php的版本等信息即为php搭建成功，进行下一步</p><h2 id="安装phpmyadmin-本文重点）"><a href="#安装phpmyadmin-本文重点）" class="headerlink" title="安装phpmyadmin (本文重点）"></a>安装phpmyadmin (本文重点）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">yay -S phpmyadmin <span class="comment">#安装之后路经在/usr/share/webapps/phpMyAdmin</span></span><br><span class="line">vim /etc/php/php.ini</span><br><span class="line">extension=pdo_mysql.so</span><br><span class="line">extension=mysqli.so</span><br><span class="line"><span class="comment">#取消掉这两行的注释，以启动扩展，注PHP 7.0 中 删除了mysql.so。</span></span><br><span class="line"><span class="comment">#可以给网络脚本最低的 MySQL 用户权限，可以编辑 /etc/mysql/my.cnf 取消 skip-networking 行的注释，这样 MySQL 服务器就只能本地访问。设置之后需要重启 MySQL。</span></span><br><span class="line"><span class="comment">#也可以启用 extension=bz2 和 extension=zip 扩展以支持压缩</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建Apache配置文件</span></span><br><span class="line">/etc/httpd/conf/extra/phpmyadmin.conf</span><br><span class="line">Alias /phpmyadmin <span class="string">&quot;/usr/share/webapps/phpMyAdmin&quot;</span></span><br><span class="line">&lt;Directory <span class="string">&quot;/usr/share/webapps/phpMyAdmin&quot;</span>&gt;</span><br><span class="line">    DirectoryIndex index.php</span><br><span class="line">    AllowOverride All</span><br><span class="line">    Options FollowSymlinks</span><br><span class="line">    Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"><span class="comment">#在/etc/httpd/conf/httpd.conf加入配置文件：</span></span><br><span class="line">Include conf/extra/phpmyadmin.conf</span><br></pre></td></tr></table></figure><p>之后打开localhost/phpmyadmin即可看到登录界面，如果看不到可以选择手动链接（或者拷贝）phpmyadmin到/srv/http目录然后手动打开index.php文件也可</p><p><a href="https://wiki.archlinux.org/index.php/PhpMyAdmin">参考phpmyadmin</a><br><a href="https://wiki.archlinux.org/index.php/Apache_HTTP_Server#PHP">参考apache</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> mysql </tag>
            
            <tag> lamp </tag>
            
            <tag> phpmyadmin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装mysql（MariaDb）在manjaro中</title>
      <link href="/2021/04/10/study_blog/Linux/LAMP/2021-04-10-intall_mysql_in_manjaro/"/>
      <url>/2021/04/10/study_blog/Linux/LAMP/2021-04-10-intall_mysql_in_manjaro/</url>
      
        <content type="html"><![CDATA[<h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S mysql</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mysqld</span><br><span class="line">sudo /usr/bin/mysql_secure_installation</span><br><span class="line"><span class="comment"># 第一个是输入密码，默认是无（即直接回车）</span></span><br><span class="line"><span class="comment"># 第三个是是否改变密码</span></span><br><span class="line"><span class="comment"># 第四个禁止远程root登录</span></span><br><span class="line"><span class="comment"># 第五个重新载入权限表</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code>* 进入     mysql -u root -p* 增加用户    CREATE USER &#39;a&#39;@&#39;localhost&#39; IDENTIFIED by &#39;mysql_a&#39;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> mysql </tag>
            
            <tag> start </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习_本地同步至github（ssh方式）</title>
      <link href="/2020/09/23/study_blog/Git/2020-09-23-git_sync/"/>
      <url>/2020/09/23/study_blog/Git/2020-09-23-git_sync/</url>
      
        <content type="html"><![CDATA[<h1 id="1-安装以及配置"><a href="#1-安装以及配置" class="headerlink" title="1.安装以及配置"></a>1.安装以及配置</h1><ul><li>1.1 intall：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git <span class="comment">#ubuntu</span></span><br><span class="line">sudo pacman -S git <span class="comment">#manjaro</span></span><br></pre></td></tr></table></figure></li><li>1.2 config <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config  —global user.name “github_name”</span><br><span class="line">git config—global user.email “github_emil” <span class="comment">#自己的GitHub名字和email</span></span><br></pre></td></tr></table></figure></li><li>如果和github端不同会出错*</li><li>1.3关联ssh<pre><code>    * 1.3.1 #生成密钥对</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -C “标识符，想写啥写啥“ <span class="comment">#生成一个密钥对</span></span><br></pre></td></tr></table></figure>1.3.2<pre><code>  在github上找到  setting-&gt;ssh and GPG keys-&gt; new key  然后点击添加ssh，复制公钥到内容里面去，titl内容自己填，便于区分  *公钥文件在 ～/.ssh/id_rsa.pub*    </code></pre></li></ul><p> 1.3.3<br> 测试是否连通<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><h1 id="2-本地同步至github"><a href="#2-本地同步至github" class="headerlink" title="2.本地同步至github"></a>2.本地同步至github</h1><ul><li>2.1github中新建一个repository</li><li>2.2 同步内容(新建一个文件夹或者clone一个仓库）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment">#初始化仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/user_name/repository<span class="comment">#或者克隆那个仓库</span></span><br><span class="line">touch README.md <span class="comment">#建立readme文件</span></span><br><span class="line"><span class="built_in">echo</span> ”<span class="built_in">test</span> <span class="keyword">for</span> sync“ &gt;README.md</span><br><span class="line">git add README.md <span class="comment">#添加一个文件到项目里面</span></span><br><span class="line">git commit README.md  -m “first commit”<span class="comment">#第一次提交 m选项是添加提交评论，以便区分</span></span><br><span class="line">git remote add first git@github:[user_name]/[repository].git<span class="comment">#添加推送（远程连接源）</span></span><br><span class="line">git push first -u  master <span class="comment">#推送，u选项是选择分支，默认是master，可省略。</span></span><br></pre></td></tr></table></figure></li><li>2.3 以后<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment">#同步github端的修改，拉取</span></span><br><span class="line">git add [new_file] <span class="comment">#添加新的文件进去，如果是本来有的可以不用添加</span></span><br><span class="line">git commit [new_file] [change_file] -m “继续写本次提交的内容批注” <span class="comment">#commit后面跟新文件和原来存在但修改了的文件</span></span><br><span class="line">git push first<span class="comment">#推送修改</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我和manjaro</title>
      <link href="/2020/09/13/study_blog/Linux/2020-09-13-I_and_manjaro/"/>
      <url>/2020/09/13/study_blog/Linux/2020-09-13-I_and_manjaro/</url>
      
        <content type="html"><![CDATA[<blockquote><p>古有 工欲善其事 必先利其器<br>今有  打造一个漂亮  快捷的环境 使自己越看越想看自己的电脑</p></blockquote><h2 id="选择的原因"><a href="#选择的原因" class="headerlink" title="选择的原因"></a>选择的原因</h2><p>刚开始接触vim的时候，一直想吐槽。咋会有这么繁琐且恶心的编辑器？友好点它不行吗？但其实知道了：q是退出之后i是插入之后，好像也基本能用了，只是速度极其缓慢。于是便有了其他快捷键。感觉就是，起点很低，或者说就只是个单纯的编辑器，但没有上限，甚至可以打造了媲美IDE。<br>但，keep it simple，stupid。这样挺好<br>久而久之。当使用到其他编辑器，遇到机械性处理时，总不免想到，这如果放在vim下，那可就不用重复性机械运动了啊。<br>也许是喜欢kiss（keep it simple，stupid）理念的原因，或许是对GNU计划的倾佩，又或许是对自己简单骚动。<br>所以打造一个自己大概知道它的环境。</p><h2 id="选择manjaro的原因"><a href="#选择manjaro的原因" class="headerlink" title="选择manjaro的原因"></a>选择manjaro的原因</h2><p>首当其冲的当然是菜啊，如果能优秀一些，直接上arch，所有的都自己配置一顿。但认清自己的菜之后，还是使用些较为友好的。</p><h4 id="对Linux内核的思考"><a href="#对Linux内核的思考" class="headerlink" title="对Linux内核的思考"></a>对Linux内核的思考</h4><p>linux衍生出那么多的发行版，<br>    - ubuntu 使用的包管理器是apt，使用的桌面是gnome<br>    - centos使用的包管理器是yum，使用的桌面是xfce（可选，作为服务器一般没有，作为个人使用我装过xfce，因为耗资源少，捂脸）<br>    - deepin使用apt，使用的桌面是深度自己的<br>    - manjaro使用的包管理器是pacman，使用的桌面可选。（同上）<br>为什么他们都叫linux系统，但许多软件并不通用呢？<br>我的理解是，linux是微内核，也就是只有内核层次是linux，其余的包管理器，桌面这些可作为服务的安装上去，供自己选择，这或许就是自由的原因把。与此相对的是Windows，打开之后包管理器，桌面，等都是已有的，不是自己可供选择的。<br>    包管理器是基本的，提供一个给其他软件运行的环境和管理，所以得安装。桌面是一个和shell（外壳）和内核对话，不要桌面得话其实也行，直接进最初黑漆漆得终端也行，不过这个shell真的太黑了，缺乏必要得美感。<br>    图形可视化的shell其实除了我们日常最常见的桌面，还有一种只保留最基本功能的，也就是窗口管理器，功能非常的少，不像任一桌面一样丰富与健全，但也许这也是它的优点，没啥功能，所以你能一下就知道看到它的所有，（捂脸）简单，但也不简单</p><h4 id="i3-alacritty-chrome-ranger-zsh-vim"><a href="#i3-alacritty-chrome-ranger-zsh-vim" class="headerlink" title="i3+alacritty+chrome+ranger+zsh+vim"></a>i3+alacritty+chrome+ranger+zsh+vim</h4><p>废话那么多，开始进入正题。</p><ul><li>底层用pacman包管理器，shell是可视化（我不是那种活在黑漆漆的终端下的人）</li><li>可视化shell使用窗口管理器i3（为啥不叫桌面呢？因为虽然也是可视化的图形界面，但是在太简单了，就只有窗口，没事，够简单）</li><li>有了i3这图形shell之后，主要使用的就是终端和浏览器</li><li>浏览器使用chrome，终端使用alacritty，软件使用终端生态下的软件</li><li>比如文件管理器ranger</li><li>shell语言zsh</li><li>编辑器vim<br>他们之间的逻辑关系大概如下<img src="https://img-blog.csdnimg.cn/20200913204608129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Nzk3MDg2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>附上几张现在的桌面，渲染器使用的是picom。</li></ul><ul><li>i3本尊<br><img src="https://img-blog.csdnimg.cn/20200913204820296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Nzk3MDg2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul><ul><li>alacritty本尊<br><img src="https://img-blog.csdnimg.cn/20200913204953330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Nzk3MDg2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>alacritty+chrome<br><img src="https://img-blog.csdnimg.cn/20200913205105899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Nzk3MDg2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>alacritty+ranger</li></ul><p><img src="https://img-blog.csdnimg.cn/20200913205219574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Nzk3MDg2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>alacritty+vim<br><img src="https://img-blog.csdnimg.cn/20200913205417327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Nzk3MDg2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>alacritty+vim+ranger</li></ul><p><img src="https://img-blog.csdnimg.cn/20200913205536368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Nzk3MDg2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>生活很大，但大抵使用的好像也没几个软件 ，简单些，便捷些。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> manjaro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dd和cp的硬盘上的区别</title>
      <link href="/2020/09/06/study_blog/Linux/command/2020-09-06-cp_and_dd/"/>
      <url>/2020/09/06/study_blog/Linux/command/2020-09-06-cp_and_dd/</url>
      
        <content type="html"><![CDATA[<h1 id="dd和cp的硬盘上的区别"><a href="#dd和cp的硬盘上的区别" class="headerlink" title="dd和cp的硬盘上的区别"></a>dd和cp的硬盘上的区别</h1><p>环境：软盘fd（使用bximage制造），<br>文件系统类型 ：fat<br><img src="https://img-blog.csdnimg.cn/20200906211514120.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Nzk3MDg2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（附图：fat文件系统的文件排布）</p><p>制作软盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ bximgae</span><br><span class="line">$ mkfs.fat a.img <span class="comment">#格式化软盘 ，使其文件系统类型为fat</span></span><br><span class="line">$ hexdump a.img <span class="comment">#显示空白，等于空硬盘</span></span><br><span class="line">$ mkdir temp | sudo mount a.img <span class="built_in">test</span>/ <span class="comment">#创建一个文件夹 并挂载软盘</span></span><br><span class="line">$ <span class="built_in">cd</span> temp </span><br><span class="line">$ touch hello.txt <span class="comment">#建立新文件</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;huaixu&quot;</span> &gt;hello.txt <span class="comment">#写入hello.txt文件内容hauixu，&gt;是重定向符</span></span><br><span class="line">$ cp hello.txt cp.txt <span class="comment">#复制文件</span></span><br><span class="line">$ dd <span class="keyword">if</span>=hello.txt of=dd.txt <span class="comment"># 使用dd“刻录”（也许用词不准确）文件</span></span><br><span class="line">$ cat hello.txt cp.txt dd.txt <span class="comment">#查看文件  </span></span><br><span class="line"><span class="comment">#显示的结果都是huaixu</span></span><br><span class="line">$ <span class="built_in">cd</span>.. <span class="comment">#返回上一级目录</span></span><br><span class="line">$ sudo umount /dev/loop0 <span class="comment">#卸载磁盘（可能也叫弹出）</span></span><br></pre></td></tr></table></figure><p>然后使用hexdump -C a.img查看硬盘  显示的内容（前面的软盘信息忽略）<br><img src="https://img-blog.csdnimg.cn/20200906212906790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Nzk3MDg2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看到再倒数第二位那里  hello.txt文件和dd.txt相同  为72.开始簇号，而cp的不一样  为67.</p><p>结论，cp会改变文件再磁盘上的位置  dd刻录磁盘文件时候包括位置</p><blockquote><p>附：1.bximage制作的硬盘后缀也是.img<br>2.结果只限于fat文件，也用硬盘的ext4文件系统实验过，不过结果不太理想，我找不出位置  而且  文件寻根表好像有三个（fat的有两个？（可能记错））<br>3.fat为window下的文件系统  默认的文件系统  ext4为linux 下默认的文件系统（至少Ubuntu的是）比如U盘这些格式化默认是这个。fat32是fat fat12的升级，ext4是ext ext2的升级版  </p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200906214010928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Nzk3MDg2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-换仓库源</title>
      <link href="/2020/06/17/study_blog/docker/2020-06-17-docker_change_repo/"/>
      <url>/2020/06/17/study_blog/docker/2020-06-17-docker_change_repo/</url>
      
        <content type="html"><![CDATA[<h2 id="docker换仓库"><a href="#docker换仓库" class="headerlink" title="==docker换仓库=="></a>==docker换仓库==</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/docker/daemon.json</span><br><span class="line">vim daemon.json</span><br><span class="line"><span class="comment">#vim  中输入</span></span><br><span class="line">&#123;</span><br><span class="line">“registry-mirrors”:[“https:****”]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>国内的几个源：</p><ul><li>Docker 官方中国区：<a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></li><li>网易：<a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></li><li>中国科技大学：<a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></li><li>阿里云：<a href="https://y0qd3iq.mirror.aliyuncs.com/">https://y0qd3iq.mirror.aliyuncs.com</a></li></ul><h2 id="重启服务"><a href="#重启服务" class="headerlink" title="==重启服务=="></a>==重启服务==</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload <span class="comment">#重载入daemom</span></span><br><span class="line">systemctl restart docker <span class="comment">#重新启动docker</span></span><br><span class="line">docker info |grep Mirros -A 1 <span class="comment">#查看换源是否成功</span></span><br></pre></td></tr></table></figure><h3 id="也许会发生的错误"><a href="#也许会发生的错误" class="headerlink" title="也许会发生的错误"></a><em>也许会发生的错误</em></h3><p>重启不了，使用systemctl status docker 看到错误时</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Job <span class="keyword">for</span> docker.service failed because the control process exited with error code.</span><br></pre></td></tr></table></figure><p>估计是换源的时候daemon的配置文件有错误。<strong>注意大小写，符号，最外面有一个花括号</strong><br>之后继续尝试 <em>重启服务</em></p><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><blockquote><p>配置文件一般在/etc目录下（和服务有关的，还有apt的也是在这里，好像yum也是）<br>配置文件一般在个人home目录下的隐藏目录\隐藏文件（个人特色的，例如vim的.vimrc 和pip的 ~/.pip/pip.conf)<br>个人感觉区别在于前者是更替电脑的某些配置（需要sudo才能使用）<br>后者在于配置个人用户的偏好设置，</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万分之一（对经济自由的个人定义）</title>
      <link href="/2020/03/11/think_life/2020-03-11-one_in_ten_thousand/"/>
      <url>/2020/03/11/think_life/2020-03-11-one_in_ten_thousand/</url>
      
        <content type="html"><![CDATA[<blockquote><p>定义的经济自由数值标准<br>阶段：个人阶段（未结婚，无固定资产）<br><strong>每日金额大于.所能支配的一万分之一</strong> </p></blockquote><h2 id="指标："><a href="#指标：" class="headerlink" title="指标："></a>指标：</h2><ul><li>衣食住行</li><li>订阅费（每月订阅服务所产生费用，每年订阅学费等等）</li><li>have done(已购买的大件物品按照预期使用年限，相应平均到每一天）<h2 id="eg"><a href="#eg" class="headerlink" title="eg:"></a>eg:</h2></li></ul><table><thead><tr><th></th><th>object</th><th>time</th><th>price</th><th>per day</th><th>per month</th><th>per year</th><th>comment</th></tr></thead><tbody><tr><td>have done</td><td>computer</td><td>start-end</td><td><del>price</del></td><td></td><td></td><td></td><td>4 year</td></tr><tr><td></td><td>phone</td><td>start-end</td><td><del>price</del></td><td></td><td></td><td></td><td>2year</td></tr><tr><td>subscriptions</td><td>phone bill</td><td></td><td></td><td></td><td><del>price</del></td><td></td><td>month</td></tr><tr><td></td><td>vip</td><td></td><td></td><td></td><td><del>price</del></td><td></td><td>month</td></tr><tr><td></td><td>学费</td><td></td><td></td><td></td><td></td><td><del>price</del></td><td></td></tr><tr><td></td><td>住宿</td><td></td><td></td><td></td><td></td><td><del>price</del></td><td></td></tr><tr><td>life</td><td>food</td><td></td><td></td><td></td><td><del>price</del></td><td></td><td></td></tr><tr><td></td><td>fruit</td><td></td><td></td><td></td><td><del>price</del></td><td></td><td></td></tr><tr><td></td><td>clothes</td><td></td><td></td><td></td><td></td><td><del>price</del></td><td></td></tr><tr><td></td><td>车费</td><td></td><td></td><td></td><td></td><td><del>price</del></td><td></td></tr><tr><td>total</td><td></td><td></td><td></td><td>每日金额</td><td>每月金额</td><td>每年金额</td><td></td></tr></tbody></table><blockquote><p>备注1,根据交费不同时间段，平均于每日，每月，每年。其中所属时间段有强调<br>备注2,</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济自由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker学习3-镜像制作</title>
      <link href="/2019/12/30/study_blog/docker/2019-12-30-docker3/"/>
      <url>/2019/12/30/study_blog/docker/2019-12-30-docker3/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"> A(镜像组成)  --&gt; B[docker commit]</span><br><span class="line">A --&gt;C[Dockerfile]</span><br><span class="line">C--&gt;D[常用命令]</span><br><span class="line">D --&gt;E[镜像]</span><br><span class="line">B--&gt;E</span><br></pre></td></tr></table></figure><h2 id="镜像组成（镜像层-容器层）"><a href="#镜像组成（镜像层-容器层）" class="headerlink" title="镜像组成（镜像层+容器层）"></a>镜像组成（镜像层+容器层）</h2><ul><li>内核共用host的内核（eg. uname -r容器内外一样）</li><li>镜像层可读、不可修改，且叠加只出现第一次出现的内容</li><li>容器层可写</li><li>base镜像（一般是环境）：不依赖其他镜像，从scratch开始；其他镜像从基础镜像扩展出</li></ul><h2 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a>镜像制作</h2><h3 id="1-docker-commit"><a href="#1-docker-commit" class="headerlink" title="1.docker commit"></a>1.docker commit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it centos</span><br><span class="line">yum install -y vim  <span class="comment">#（执行前需要配置repo库，不然会使用默认的）</span></span><br><span class="line"><span class="comment">#另一个终端</span></span><br><span class="line">docker commit  [name0]  [name1]</span><br></pre></td></tr></table></figure><p>两个镜像都会存在。</p><h3 id="2-Dockerfile"><a href="#2-Dockerfile" class="headerlink" title="2.Dockerfile"></a>2.Dockerfile</h3><p>最小的镜像的Dockerfile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM  scratch</span><br><span class="line">ADD hello  /</span><br><span class="line">CMD [<span class="string">&quot;/hello&quot;</span>]</span><br><span class="line"><span class="comment">#终端</span></span><br><span class="line">docker build -t [name]  <span class="comment">#  t 指定名字</span></span><br></pre></td></tr></table></figure><p>Dockerfile不产生中间镜像<br> 等同于上面的docker commit<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN  yum makecache &amp;&amp; yum install -y vim</span><br></pre></td></tr></table></figure><br> 3.Dockerfile 常用指令<br> FROM :指定base镜像<br> MAITAINER：指定作者名<br> COPY：复制到镜像<br> ADD：复制到镜像，如果是压缩包等，自动解压。<br> ENV:添加环境变量<br> EXPOSE ：指定容器监听一个端口<br> VOLUME：将文件或目录声明成volume，做容器储存使用<br> RUN：在容器中运行指定命令（执行command并常生镜像，常用作安装软件）<br>CMD：启动容器运行指令<br>ENTRYPOINT：容器启动里面运行命令（与cmd区别）<br>WORKDIR：指定目录</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker学习2_docker组件</title>
      <link href="/2019/12/26/study_blog/docker/2019-12-26-docker2/"/>
      <url>/2019/12/26/study_blog/docker/2019-12-26-docker2/</url>
      
        <content type="html"><![CDATA[<h2 id="docker-component"><a href="#docker-component" class="headerlink" title="docker component"></a>docker component</h2><table><thead><tr><th>1</th><th>Docker client</th><th>client</th></tr></thead><tbody><tr><td>2</td><td>Docker server</td><td>daemon</td></tr><tr><td>3</td><td>Docker Image</td><td>Image</td></tr><tr><td>4</td><td>registry</td><td>dockerhub/daocloud</td></tr><tr><td>5</td><td>Docker Container</td><td>container</td></tr></tbody></table><h2 id="mind-map"><a href="#mind-map" class="headerlink" title="mind map"></a>mind map</h2><p><img src="https://img-blog.csdnimg.cn/20191223235539764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Nzk3MDg2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="run-example"><a href="#run-example" class="headerlink" title="run example"></a>run example</h2><p>==命令不附效果图，动手去做，胜于看==</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 httpd </span><br><span class="line"><span class="comment">#-d detach(分离）在后台运行  -p 指定端口</span></span><br><span class="line">docker images <span class="comment">#查看镜像</span></span><br><span class="line">docker ps <span class="comment">#查看容器状态</span></span><br></pre></td></tr></table></figure><p>可以联系上面的图，client发出命令，daemon执行，如果本地没有镜像则向registry拉取。</p><h2 id="通信远程客户端"><a href="#通信远程客户端" class="headerlink" title="通信远程客户端"></a>通信远程客户端</h2><p>docker默认只接受本机client的命令，但可设置接收远端的命令，允许远程配置请求<br><strong>打开TCP监听</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/multiuser.target.wants/docker.service</span><br><span class="line"><span class="comment">#在ExecStart 后附加   -H tcp://0.0.0.0</span></span><br><span class="line"><span class="comment">#-H host,0.0.0.0允许所有的远端</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker.service</span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line">docker  -H [ip]  info</span><br><span class="line"><span class="comment">#测试远端，查看远端docker的信息</span></span><br></pre></td></tr></table></figure><h2 id="image和其他文件之间的转化"><a href="#image和其他文件之间的转化" class="headerlink" title="image和其他文件之间的转化"></a>image和其他文件之间的转化</h2><p><img src="https://img-blog.csdnimg.cn/20191225171319620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Nzk3MDg2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s学习_1.体验集群</title>
      <link href="/2019/12/25/study_blog/docker/2019-12-25-k8s1/"/>
      <url>/2019/12/25/study_blog/docker/2019-12-25-k8s1/</url>
      
        <content type="html"><![CDATA[<h2 id="minikube-–最小集群模拟"><a href="#minikube-–最小集群模拟" class="headerlink" title="minikube –最小集群模拟"></a>minikube –最小集群模拟</h2><ul><li>Install</li><li>Online Internet（recommend）<br>不推荐安装，推荐在线体验，因为入门之际，先探其美。<a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/create-cluster/cluster-interactive/">点这</a>。官方的教程中可以体验。<br><img src="https://img-blog.csdnimg.cn/20191223212959187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Nzk3MDg2,size_16,color_FFFFFF,t_70" alt="官方教程入门图片"><h2 id="体验命令"><a href="#体验命令" class="headerlink" title="体验命令"></a>体验命令</h2>==命令不附效果图，动手去做，胜于看==<h3 id="begin"><a href="#begin" class="headerlink" title="begin"></a>begin</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">minikube start     <span class="comment">#开始</span></span><br><span class="line">kubectl get nodes     <span class="comment">#查看节点</span></span><br><span class="line">hostname    <span class="comment">#主机名称</span></span><br><span class="line">kubectl cluter-info   <span class="comment">#查看集群信息</span></span><br></pre></td></tr></table></figure><h3 id="run-image"><a href="#run-image" class="headerlink" title="run image"></a>run image</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl run kubernetes-bootcamp \     <span class="comment">#指定镜像名字</span></span><br><span class="line">--image=docker.io/jocatalin/kubernetes-bootcamp:v1 \  <span class="comment">#指定镜像地址</span></span><br><span class="line">--port=8080      <span class="comment">#指定对外端口</span></span><br><span class="line"></span><br><span class="line">kubectl get pods  <span class="comment">#获取pod</span></span><br></pre></td></tr></table></figure><h3 id="expose-pod"><a href="#expose-pod" class="headerlink" title="expose pod"></a>expose pod</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose deployments/kubernetes-bootcamp \</span><br><span class="line">--<span class="built_in">type</span>=<span class="string">&quot;NodePort&quot;</span></span><br><span class="line">--port=8080    <span class="comment">#指定端口</span></span><br><span class="line">kubectl get service <span class="comment">#查看服务，查看映射端口</span></span><br><span class="line">curl  [hostname]:[port]   <span class="comment">#验证结果</span></span><br></pre></td></tr></table></figure><h3 id="scale-app"><a href="#scale-app" class="headerlink" title="scale app"></a>scale app</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployments   <span class="comment">#查看全部应用信息</span></span><br><span class="line">kubectl scale deployments/kubernetes-bootcamp --replicas=3  </span><br><span class="line">kubectl get deployments <span class="comment">#验证</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">kubectl scale deployments/kubernetes-bootcamp  --replicas=2   <span class="comment">#scale down</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="mind-map"><a href="#mind-map" class="headerlink" title="mind map"></a>mind map</h3><p><img src="https://img-blog.csdnimg.cn/20191225164749634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Nzk3MDg2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>单节点，node物理机，pod最小管理单位，deployment部署应用<br>kubectl：k8s组件之一，管理者。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker学习_1、容器生态系统</title>
      <link href="/2019/12/21/study_blog/docker/2019-12-21-docker1/"/>
      <url>/2019/12/21/study_blog/docker/2019-12-21-docker1/</url>
      
        <content type="html"><![CDATA[<h1 id="container-ecosystem"><a href="#container-ecosystem" class="headerlink" title="container ecosystem"></a>container ecosystem</h1><p>容器生态系统，思维导图<br>自己的小理解，仅作为捋思路使用。</p><h2 id="容器技术的背景、基础结构"><a href="#容器技术的背景、基础结构" class="headerlink" title="容器技术的背景、基础结构"></a>容器技术的背景、基础结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A((contrainer ecosystem))--&gt;B(Kernel)</span><br><span class="line">A--&gt;C(Platform)</span><br><span class="line">A--&gt;D(Suport)</span><br></pre></td></tr></table></figure><p>容器生态主要分为三块大的组成，核心技术、平台、支持技术</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(Kernel)--&gt;B[Container  specification]</span><br><span class="line">A--&gt;C[Container runtime]</span><br><span class="line">A--&gt;D[Container manager]</span><br><span class="line">A--&gt;E[Container definition]</span><br><span class="line">A--&gt;F[Registry]</span><br><span class="line">A--&gt;G[Container OS]</span><br><span class="line">B--&gt;b1(Runtime spec)</span><br><span class="line">B--&gt;b2(Image format spec)</span><br><span class="line">C--&gt;c1(lxc)</span><br><span class="line">C--&gt;c2(runc)</span><br><span class="line">C--&gt;c3(rkt)</span><br><span class="line">D--&gt;d1(lxd)</span><br><span class="line">D--&gt;d2(docker engine)</span><br><span class="line">D--&gt;d4(rkt cli)</span><br><span class="line">E--&gt;e1(docker image)</span><br><span class="line">E--&gt;e2(dockerfile)</span><br><span class="line">E--&gt;e3(ACI:app container image)</span><br><span class="line">F--&gt;f1(docker registry)</span><br><span class="line">F--&gt;f2(docker hub)</span><br><span class="line">F--&gt;f3(.....)</span><br><span class="line">G--&gt;g1(core os)</span><br><span class="line">G--&gt;g2(ubuntu core)</span><br></pre></td></tr></table></figure><h3 id="核心技术-为了一个大目标：应用环境的更广、更适用"><a href="#核心技术-为了一个大目标：应用环境的更广、更适用" class="headerlink" title="核心技术==为了一个大目标：应用环境的更广、更适用=="></a>核心技术==为了一个大目标：应用环境的更广、更适用==</h3><ul><li>specification：标准是基础，统一容器的标准，好似usb接口取代了许多电脑接口，来源于标准化，主要使runtime和image进行标准化。</li></ul><ul><li>runtime：容器运行的环境。<br>lxd：原docker默认的runtime，来源于Linux。<br>runc：docker自己开发的runtime，先docker默认。</li><li>manger:容器的管理器，lxd是lxc的。<br> docker engine：通常所说的docker所指，主要包括daemon（服务器）、cli（客户端）</li><li>registry ：镜像库，默认是docker hub，国内个人推荐daocloud。</li><li>container OS：专门为运行镜像而做的系统。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(Platform)--&gt;B(container engine)</span><br><span class="line">A--&gt;C(container plat manager)</span><br><span class="line">A--&gt;D(container-based micro-service)</span><br><span class="line">B--&gt;b1[docker swarm]</span><br><span class="line">B--&gt;b2[kubernetes]</span><br></pre></td></tr></table></figure>这是一个群体社会，==计算机也需要集群管理==</li><li>platform：容器管理平台<br>container engine：容器编排引擎，最常用的是kubernetes（最火的）<br>docker swarm（docker自己做的）</li><li>container-based micro-service:基于容器的微服务。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(Support)--&gt;B[container network]</span><br><span class="line">A--&gt;C[container monitor]</span><br><span class="line">A--&gt;D[data manager]</span><br><span class="line">A--&gt;E[log manager]</span><br><span class="line">A--&gt;F[security]</span><br><span class="line">B--&gt;b(docker network)</span><br><span class="line">C--&gt;c1(docker ps/top/status)</span><br><span class="line">C--&gt;c2(docker status API)</span><br><span class="line">E--&gt;e1(docker logs)</span><br></pre></td></tr></table></figure><p>一个群体的运作离不开许多人在背后默默的支持， 容器的运行离不开许多的支持技术。</p><ul><li>network :docker network 是docker原生的解决网络的方案，常见的还有flanel、weave等</li><li>container monitor：容器状态监控，常见的可用docker ps直接查看容器的运行信息。</li><li>log manager：排除故障的查看之处，常见命令是docker logs</li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
